prNumber,Util,Network,Interpreter,i18n,Logic,Test,IO,App,corpus
138,1,0,0,0,0,0,1,0,implemented sequenceequal operator fixes issue #76since there is no direct analogue of `iequalitycomparer` in java `func2<t t boolean>` has been used nice and great use of the zip operator! || thank you again @mairbek  ||
138,1,0,1,0,0,0,1,0,implemented sequenceequal operator fixes issue #76since there is no direct analogue of `iequalitycomparer` in java `func2<t t boolean>` has been used nice and great use of the zip operator! || thank you again @mairbek  ||
138,1,0,1,0,0,1,1,1,implemented sequenceequal operator fixes issue #76since there is no direct analogue of `iequalitycomparer` in java `func2<t t boolean>` has been used nice and great use of the zip operator! || thank you again @mairbek  ||
146,1,0,0,0,0,0,1,0,merge of pull #125 for issue #87 operator takewhile manually merging  from @mairbek implementation of  done by @mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch ||
146,1,0,1,0,0,1,1,1,merge of pull #125 for issue #87 operator takewhile manually merging  from @mairbek implementation of  done by @mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch ||
146,1,0,1,0,0,0,1,0,merge of pull #125 for issue #87 operator takewhile manually merging  from @mairbek implementation of  done by @mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch ||
146,1,0,0,0,0,0,1,0,merge of pull #125 for issue #87 operator takewhile manually merging  from @mairbek implementation of  done by @mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch ||
146,1,0,1,0,0,1,1,1,merge of pull #125 for issue #87 operator takewhile manually merging  from @mairbek implementation of  done by @mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch ||
146,1,0,0,1,1,1,1,1,merge of pull #125 for issue #87 operator takewhile manually merging  from @mairbek implementation of  done by @mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch ||
156,1,0,0,0,0,0,1,0,implemented toiterable operation for issue #18this would allow to implement other blocking methods like `single` `lastordefault` next this looks good merging ||
156,1,0,1,0,0,1,1,1,implemented toiterable operation for issue #18this would allow to implement other blocking methods like `single` `lastordefault` next this looks good merging ||
156,1,0,1,0,0,1,1,1,implemented toiterable operation for issue #18this would allow to implement other blocking methods like `single` `lastordefault` next this looks good merging ||
165,1,0,0,0,0,0,1,0, bug in ranges  issue #164 #3 
165,1,0,1,0,0,0,1,0, bug in ranges  issue #164 #3 
165,1,0,0,1,1,1,1,1, bug in ranges  issue #164 #3 
205,1,0,0,0,0,0,1,0,reimplementation of concat improved handling of observable<observable<t >>the old version required all of the observable<t>s to be generated and bufferedbefore the concat could begin  if the outer observable was asynchronous itemscould be dropped (test added)  the new version passes the test and does thebest job i could (after examining several possible strategies) of achievingclear and consistent semantics in accordance with the principle of leastsurprise(my attempt to  #202) #45] there is another issue with this implementation  the countdown latch will always block the calling thread which is not desirable  anything that returns an observable should never be blocking  rx is meant to support composition of operations and allows each operation to run concurrently || while reviewing this i started playing with the unit tests and added 2 new ones i also made them use inorderverify so they ensure correct ordering ive pasted it below so you can merge into your branch instead of me complicating the merge with another branch the tests pass pass except `testconcatunsubscribe` which deadlocks it does this because a list<observable> wont return the subscription asynchronously so it cant unsubscribe meanwhile a countdownlatch is waiting for the change to trigger and the two latches end up waiting on each otheri havent thought through enough yet to determine if there is a way to solve that or if the unit test is just testing the wrong thing and thus a bad testthe comment above from @billy about countdownlatch originated from a discussion between him and i - but while reviewing this it is probably the right approachi was playing with other approaches that are purely non-blocking while retaining the correct concat sequential behavior but they all seem to require either:- another wrapping thread- stealing work from one of the child observable threads and making it do work that is queued on the others  and that seems like a bad idea even though it can be hacked to "work" but it does so in a way that is very unexpected and thus not something i want to pursue- queueing all onnext values which could be a bad memory issue  and also means we eagerly subscribe which is not what we wantmy biggest issue right now is that concat(o1 o2) is a very common usage but that results in list<observable> which will be blocking and unsubscribe doesnt workill think through this more but id appreciate your thoughts on how to handle `testconcatunsubscribe` ``` java    public static class unittest {        @test        public void testconcat() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            @suppresswarnings("unchecked")            observable<string> concat  observablecreate(concat(odds even))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        @test        public void testconcatwithlist() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            final list<observable<string>> list  new arraylist<observable<string>>()            listadd(odds)            listadd(even)            observable<string> concat  observablecreate(concat(list))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        @test        public void testconcatunsubscribe() {            final countdownlatch callonce  new countdownlatch(1)            final countdownlatch oktocontinue  new countdownlatch(1)            final testobservable<string> w1  new testobservable<string>("one" "two" "three")            final testobservable<string> w2  new testobservable<string>(callonce oktocontinue "four" "five" "six")            @suppresswarnings("unchecked")            observer<string> aobserver  mock(observerclass)            @suppresswarnings("unchecked")            observable<string> concat  observablecreate(concat(w1 w2))            systemoutprintln("before subscribe")            subscription s1  concatsubscribe(aobserver)            systemoutprintln("after subscribe")            try {                //block main thread to allow observable "w1" to complete and observable "w2" to call onnext once                systemoutprintln("before callonceawait")                callonceawait()                systemoutprintln("after callonceawait")                s1unsubscribe()                systemoutprintln("after s1unsubscribe")                //unblock the observable to continue                oktocontinuecountdown()                systemoutprintln("after countdown")                w1tjoin()                w2tjoin()            } catch (exception e) {                eprintstacktrace()                fail(egetmessage())            }            inorder inorder  inorder(aobserver)            inorderverify(aobserver times(1))onnext("one")            inorderverify(aobserver times(1))onnext("two")            inorderverify(aobserver times(1))onnext("three")            inorderverify(aobserver times(1))onnext("four")            inorderverify(aobserver never())onnext("five")            inorderverify(aobserver never())onnext("six")            inorderverify(aobserver times(1))oncompleted()        }        @test        public void testmergeobservableofobservables() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {                @override                public subscription call(observer<observable<string>> observer) {                    // simulate what would happen in an observable                    observeronnext(odds)                    observeronnext(even)                    observeroncompleted()                    return new subscription() {                        @override                        public void unsubscribe() {                            // unregister  will never be called here since we are executing synchronously                        }                    }                }            })            observable<string> concat  observablecreate(concat(observableofobservables))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        /**         * simple concat of 2 asynchronous observables ensuring it emits in correct order         */        @suppresswarnings("unchecked")        @test        public void testsimpleasyncconcat() {            observer<string> observer  mock(observerclass)            testobservable<string> o1  new testobservable<string>("one" "two" "three")            testobservable<string> o2  new testobservable<string>("four" "five" "six")            observableconcat(o1 o2)subscribe(observer)            try {                // wait for async observables to complete                o1tjoin()                o2tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads")            }            inorder inorder  inorder(observer)            inorderverify(observer times(1))onnext("one")            inorderverify(observer times(1))onnext("two")            inorderverify(observer times(1))onnext("three")            inorderverify(observer times(1))onnext("four")            inorderverify(observer times(1))onnext("five")            inorderverify(observer times(1))onnext("six")        }        /**         * test an async observable that emits more async observables         */        @suppresswarnings("unchecked")        @test        public void testnestedasyncconcat() throws exception {            observer<string> observer  mock(observerclass)            final testobservable<string> o1  new testobservable<string>("one" "two" "three")            final testobservable<string> o2  new testobservable<string>("four" "five" "six")            final testobservable<string> o3  new testobservable<string>("seven" "eight" "nine")            final countdownlatch allowthird  new countdownlatch(1)            final atomicreference<thread> parent  new atomicreference<thread>()            observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {                @override                public subscription call(final observer<observable<string>> observer) {                    final booleansubscription s  new booleansubscription()                    parentset(new thread(new runnable() {                        @override                        public void run() {                            try {                                // emit first                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o1")                                    observeronnext(o1)                                }                                // emit second                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o2")                                    observeronnext(o2)                                }                                // wait until sometime later and emit third                                try {                                    allowthirdawait()                                } catch (interruptedexception e) {                                    observeronerror(e)                                }                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o3")                                    observeronnext(o3)                                }                            } catch (exception e) {                                observeronerror(e)                            } finally {                                systemoutprintln("done parent observable")                                observeroncompleted()                            }                        }                    }))                    parentget()start()                    return s                }            })            observablecreate(concat(observableofobservables))subscribe(observer)            // wait for parent to start            while (parentget()  null) {                threadsleep(1)            }            try {                // wait for first 2 async observables to complete                while (o1t  null) {                    threadsleep(1)                }                systemoutprintln("thread1 started  waiting for it to complete ")                o1tjoin()                while (o2t  null) {                    threadsleep(1)                }                systemoutprintln("thread2 started  waiting for it to complete ")                o2tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads" e)            }            inorder inorder  inorder(observer)            inorderverify(observer times(1))onnext("one")            inorderverify(observer times(1))onnext("two")            inorderverify(observer times(1))onnext("three")            inorderverify(observer times(1))onnext("four")            inorderverify(observer times(1))onnext("five")            inorderverify(observer times(1))onnext("six")            // we shouldnt have the following 3 yet            inorderverify(observer never())onnext("seven")            inorderverify(observer never())onnext("eight")            inorderverify(observer never())onnext("nine")            // we should not be completed yet            verify(observer never())oncompleted()            verify(observer never())onerror(any(exceptionclass))            // now allow the third            allowthirdcountdown()            try {                while (o3t  null) {                    threadsleep(1)                }                // wait for 3rd to complete                o3tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads" e)            }            inorderverify(observer times(1))onnext("seven")            inorderverify(observer times(1))onnext("eight")            inorderverify(observer times(1))onnext("nine")            inorderverify(observer times(1))oncompleted()            verify(observer never())onerror(any(exceptionclass))        }        @suppresswarnings("unchecked")        @test        public void testblockedobservableofobservables() {            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            final countdownlatch callonce  new countdownlatch(1)            final countdownlatch oktocontinue  new countdownlatch(1)            testobservable<observable<string>> observableofobservables  new testobservable<observable<string>>(callonce oktocontinue odds even)            func1<observer<string> subscription> concatf  concat(observableofobservables)            observable<string> concat  observablecreate(concatf)            concatsubscribe(observer)            try {                //block main thread to allow observables to serve up o1                callonceawait()            } catch (exception ex) {                exprintstacktrace()                fail(exgetmessage())            }            // the concated observable should have served up all of the odds            verify(observer times(1))onnext("1")            verify(observer times(1))onnext("3")            verify(observer times(1))onnext("5")            verify(observer times(1))onnext("7")            try {                // unblock observables so it can serve up o2 and complete                oktocontinuecountdown()                observableofobservablestjoin()            } catch (exception ex) {                exprintstacktrace()                fail(exgetmessage())            }            // the concatenated observable should now have served up all the evens            verify(observer times(1))onnext("2")            verify(observer times(1))onnext("4")            verify(observer times(1))onnext("6")        }        private static class testobservable<t> extends observable<t> {            private final subscription s  new subscription() {                @override                public void unsubscribe() {                    subscribed  false                }            }            private final list<t> values            private thread t  null            private int count  0            private boolean subscribed  true            private final countdownlatch once            private final countdownlatch oktocontinue            public testobservable(t values) {                this(null null values)            }            public testobservable(countdownlatch once countdownlatch oktocontinue t values) {                thisvalues  arraysaslist(values)                thisonce  once                thisoktocontinue  oktocontinue            }            @override            public subscription subscribe(final observer<t> observer) {                t  new thread(new runnable() {                    @override                    public void run() {                        try {                            while (count < valuessize() && subscribed) {                                observeronnext(valuesget(count))                                count++                                //unblock the main thread to call unsubscribe                                if (null ! once)                                    oncecountdown()                                //block until the main thread has called unsubscribe                                if (null ! once)                                    oktocontinueawait()                            }                            if (subscribed)                                observeroncompleted()                        } catch (interruptedexception e) {                            eprintstacktrace()                            fail(egetmessage())                        }                    }                })                tstart()                return s            }        }    }``` || thanks for the comments and the extra tests i have merged them anduploaded a new versionregarding testconcatunsubscribe: im still not entirely sure of my footingbut i believe the test is in error it is demonstrating exactly the issuewhich i mentioned in the new javadoc for operationconcat specifically itsets up a situation wherein the inner observables thread is blocked on theouter observables thread: the inner thread cannot proceed until the testcalls oktocontinuecountdown() which happens-afterconcatsubscribe(aobserver) which blocks until the list has delivered bothw1 and w2am i right that in general an observer should block onnext() until it hasfinished processing the item? this pushes the flow-control upstream ratherthan excessive buffering or throttling (which can be done explicitly in theoperation-chain if desired) if thats right then i think concat mustblock the outer onnext until it has finished servicing the inner sequencei do find it a little strange that observablefrom(iterable) is a "shotgunobservable" ie the subscribe() blocks until all downstream operationshave completed on all items which means it is impossible to everunsubscribe() but given that this is correct behavior i think that itmakes sense that concat(o1 o2) also cannot be unsubscribed-from i added acautionary comment to the javadoci have updated the test case to call concatsubscribe(aobserver) in abackground thread which fixes the deadlock and to expect all items to bedelivered despite an unsubscribe which makes the test pass(i had also tried those three non-blocking approaches before uploading thisversion thanks for checking my work :)on mar 27 2013 6:56 am "ben christensen" notifications@githubcom wrote:> while reviewing this i started playing with the unit tests and added 2 new> ones i also made them use inorderverify so they ensure correct ordering> ive pasted it below so you can merge into your branch instead of me> complicating the merge with another branch> > the tests pass pass except testconcatunsubscribe which deadlocks it does> this because a list wont return the subscription asynchronously so it> cant unsubscribe meanwhile a countdownlatch is waiting for the change to> trigger and the two latches end up waiting on each other> > i havent thought through enough yet to determine if there is a way to> solve that or if the unit test is just testing the wrong thing and thus a> bad test> > the comment above from @billy  about> countdownlatch originated from a discussion between him and i - but while> reviewing this it is probably the right approach> > i was playing with other approaches that are purely non-blocking while> retaining the correct concat sequential behavior but they all seem to> require either:> - another wrapping thread> - stealing work from one of the child observable threads and making it>   do work that is queued on the others  and that seems like a bad idea>   even though it can be hacked to "work" but it does so in a way that is very>   unexpected and thus not something i want to pursue> - queueing all onnext values which could be a bad memory issue  and>   also means we eagerly subscribe which is not what we want> > my biggest issue right now is that concat(o1 o2) is a very common usage> but that results in list which will be blocking and unsubscribe doesnt> work> > ill think through this more but id appreciate your thoughts on how to> handle testconcatunsubscribe> > ```> public static class unittest {> >     @test>     public void testconcat() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string o  { "1" "3" "5" "7" }>         final string e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)> >         @suppresswarnings("unchecked")>         observable<string> concat  observablecreate(concat(odds even))>         concatsubscribe(observer)> >         verify(observer times(7))onnext(anystring())>     }> >     @test>     public void testconcatwithlist() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)>         final list<observable<string>> list  new arraylist<observable<string>>()>         listadd(odds)>         listadd(even)>         observable<string> concat  observablecreate(concat(list))>         concatsubscribe(observer)> >         verify(observer times(7))onnext(anystring())>     }> >     @test>     public void testconcatunsubscribe() {>         final countdownlatch callonce  new countdownlatch(1)>         final countdownlatch oktocontinue  new countdownlatch(1)>         final testobservable<string> w1  new testobservable<string>("one" "two" "three")>         final testobservable<string> w2  new testobservable<string>(callonce oktocontinue "four" "five" "six")> >         @suppresswarnings("unchecked")>         observer<string> aobserver  mock(observerclass)>         @suppresswarnings("unchecked")>         observable<string> concat  observablecreate(concat(w1 w2))>         systemoutprintln("before subscribe")>         subscription s1  concatsubscribe(aobserver)>         systemoutprintln("after subscribe")>         try {>             //block main thread to allow observable "w1" to complete and observable "w2" to call onnext once>             systemoutprintln("before callonceawait")>             callonceawait()>             systemoutprintln("after callonceawait")>             s1unsubscribe()>             systemoutprintln("after s1unsubscribe")>             //unblock the observable to continue>             oktocontinuecountdown()>             systemoutprintln("after countdown")>             w1tjoin()>             w2tjoin()>         } catch (exception e) {>             eprintstacktrace()>             fail(egetmessage())>         }> >         inorder inorder  inorder(aobserver)>         inorderverify(aobserver times(1))onnext("one")>         inorderverify(aobserver times(1))onnext("two")>         inorderverify(aobserver times(1))onnext("three")>         inorderverify(aobserver times(1))onnext("four")>         inorderverify(aobserver never())onnext("five")>         inorderverify(aobserver never())onnext("six")>         inorderverify(aobserver times(1))oncompleted()>     }> >     @test>     public void testmergeobservableofobservables() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)> >         observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {> >             @override>             public subscription call(observer<observable<string>> observer) {>                 // simulate what would happen in an observable>                 observeronnext(odds)>                 observeronnext(even)>                 observeroncompleted()> >                 return new subscription() {> >                     @override>                     public void unsubscribe() {>                         // unregister  will never be called here since we are executing synchronously>                     }> >                 }>             }> >         })>         observable<string> concat  observablecreate(concat(observableofobservables))>         concatsubscribe(observer)>         verify(observer times(7))onnext(anystring())>     }> >     /**         * simple concat of 2 asynchronous observables ensuring it emits in correct order         */>     @suppresswarnings("unchecked")>     @test>     public void testsimpleasyncconcat() {>         observer<string> observer  mock(observerclass)> >         testobservable<string> o1  new testobservable<string>("one" "two" "three")>         testobservable<string> o2  new testobservable<string>("four" "five" "six")> >         observableconcat(o1 o2)subscribe(observer)> >         try {>             // wait for async observables to complete>             o1tjoin()>             o2tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads")>         }> >         inorder inorder  inorder(observer)>         inorderverify(observer times(1))onnext("one")>         inorderverify(observer times(1))onnext("two")>         inorderverify(observer times(1))onnext("three")>         inorderverify(observer times(1))onnext("four")>         inorderverify(observer times(1))onnext("five")>         inorderverify(observer times(1))onnext("six")>     }> >     /**         * test an async observable that emits more async observables         */>     @suppresswarnings("unchecked")>     @test>     public void testnestedasyncconcat() throws exception {>         observer<string> observer  mock(observerclass)> >         final testobservable<string> o1  new testobservable<string>("one" "two" "three")>         final testobservable<string> o2  new testobservable<string>("four" "five" "six")>         final testobservable<string> o3  new testobservable<string>("seven" "eight" "nine")>         final countdownlatch allowthird  new countdownlatch(1)> >         final atomicreference<thread> parent  new atomicreference<thread>()>         observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {> >             @override>             public subscription call(final observer<observable<string>> observer) {>                 final booleansubscription s  new booleansubscription()>                 parentset(new thread(new runnable() {> >                     @override>                     public void run() {>                         try {>                             // emit first>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o1")>                                 observeronnext(o1)>                             }>                             // emit second>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o2")>                                 observeronnext(o2)>                             }> >                             // wait until sometime later and emit third>                             try {>                                 allowthirdawait()>                             } catch (interruptedexception e) {>                                 observeronerror(e)>                             }>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o3")>                                 observeronnext(o3)>                             }> >                         } catch (exception e) {>                             observeronerror(e)>                         } finally {>                             systemoutprintln("done parent observable")>                             observeroncompleted()>                         }>                     }>                 }))>                 parentget()start()>                 return s>             }>         })> >         observablecreate(concat(observableofobservables))subscribe(observer)> >         // wait for parent to start>         while (parentget()  null) {>             threadsleep(1)>         }> >         try {>             // wait for first 2 async observables to complete>             while (o1t  null) {>                 threadsleep(1)>             }>             systemoutprintln("thread1 started  waiting for it to complete ")>             o1tjoin()>             while (o2t  null) {>                 threadsleep(1)>             }>             systemoutprintln("thread2 started  waiting for it to complete ")>             o2tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads" e)>         }> >         inorder inorder  inorder(observer)>         inorderverify(observer times(1))onnext("one")>         inorderverify(observer times(1))onnext("two")>         inorderverify(observer times(1))onnext("three")>         inorderverify(observer times(1))onnext("four")>         inorderverify(observer times(1))onnext("five")>         inorderverify(observer times(1))onnext("six")>         // we shouldnt have the following 3 yet>         inorderverify(observer never())onnext("seven")>         inorderverify(observer never())onnext("eight")>         inorderverify(observer never())onnext("nine")>         // we should not be completed yet>         verify(observer never())oncompleted()>         verify(observer never())onerror(any(exceptionclass))> >         // now allow the third>         allowthirdcountdown()> >         try {>             while (o3t  null) {>                 threadsleep(1)>             }>             // wait for 3rd to complete>             o3tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads" e)>         }> >         inorderverify(observer times(1))onnext("seven")>         inorderverify(observer times(1))onnext("eight")>         inorderverify(observer times(1))onnext("nine")> >         inorderverify(observer times(1))oncompleted()>         verify(observer never())onerror(any(exceptionclass))>     }> >     @suppresswarnings("unchecked")>     @test>     public void testblockedobservableofobservables() {>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }>         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)>         final countdownlatch callonce  new countdownlatch(1)>         final countdownlatch oktocontinue  new countdownlatch(1)>         testobservable<observable<string>> observableofobservables  new testobservable<observable<string>>(callonce oktocontinue odds even)>         func1<observer<string> subscription> concatf  concat(observableofobservables)>         observable<string> concat  observablecreate(concatf)>         concatsubscribe(observer)>         try {>             //block main thread to allow observables to serve up o1>             callonceawait()>         } catch (exception ex) {>             exprintstacktrace()>             fail(exgetmessage())>         }>         // the concated observable should have served up all of the odds>         verify(observer times(1))onnext("1")>         verify(observer times(1))onnext("3")>         verify(observer times(1))onnext("5")>         verify(observer times(1))onnext("7")> >         try {>             // unblock observables so it can serve up o2 and complete>             oktocontinuecountdown()>             observableofobservablestjoin()>         } catch (exception ex) {>             exprintstacktrace()>             fail(exgetmessage())>         }>         // the concatenated observable should now have served up all the evens>         verify(observer times(1))onnext("2")>         verify(observer times(1))onnext("4")>         verify(observer times(1))onnext("6")>     }> >     private static class testobservable<t> extends observable<t> {> >         private final subscription s  new subscription() {> >             @override>             public void unsubscribe() {>                 subscribed  false>             }> >         }>         private final list<t> values>         private thread t  null>         private int count  0>         private boolean subscribed  true>         private final countdownlatch once>         private final countdownlatch oktocontinue> >         public testobservable(t values) {>             this(null null values)>         }> >         public testobservable(countdownlatch once countdownlatch oktocontinue t values) {>             thisvalues  arraysaslist(values)>             thisonce  once>             thisoktocontinue  oktocontinue>         }> >         @override>         public subscription subscribe(final observer<t> observer) {>             t  new thread(new runnable() {> >                 @override>                 public void run() {>                     try {>                         while (count < valuessize() && subscribed) {>                             observeronnext(valuesget(count))>                             count++>                             //unblock the main thread to call unsubscribe>                             if (null ! once)>                                 oncecountdown()>                             //block until the main thread has called unsubscribe>                             if (null ! once)>                                 oktocontinueawait()>                         }>                         if (subscribed)>                             observeroncompleted()>                     } catch (interruptedexception e) {>                         eprintstacktrace()>                         fail(egetmessage())>                     }>                 }> >             })>             tstart()>             return s>         }> >     }> > }> ```> > > reply to this email directly or view it on github  || #59  #60 thanks for update  let me take a look and i will do some moreresearch/thought on the testconcatsubscribe test caseon fri mar 29 2013 at 2:22 am cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #60 > this pull request looks good> > —> reply to this email directly or view it on github  || [rxjava-pull-requests #72 looks good || my original test case was intended to test the unsubscribe inside one ofchild observable   the countdownlatch was used so that the code will havea chance to unsubscribe in a predicable manner (unsubscribe after "four") in a normal case there should be no blocking between inner and outerobservable  i rewrote the case for better clarity and having the outerobservable is in a separate thread (so the test will pass now)  youbrought up a good point about "when" you can unsubscribe  should it onlyallow unsubscribe to happen during the outer onnext()?  i need to do moreresearch on it  here is the test i plan to add```    @test``` public void testconcatunsubscribeobservableofobservable() {```        final countdownlatch callonce  new countdownlatch(1)        final countdownlatch oktocontinue  new countdownlatch(1)        final testobservable<string> w1  new testobservable<string>(```"one" "two" "three")```        final testobservable<string> w2 ```newtestobservable<string>(callonce oktocontinue"four" "five" "six")```        @suppresswarnings("unchecked")        observer<string> aobserver  mock(observerclass)        @suppresswarnings("unchecked")```   testobservable<observable<string>> observableofobservables newtestobservable<observable<string>>(w1 w2)```        func1<observer<string> subscription> concatf ```concat(observableofobservables)```        observable<string> concat  observablecreate(concatf)        subscription s1  concatsubscribe(aobserver)        try {            //block main thread to allow observable "w1" to complete```and observable "w2" to call onnext exactly once```        callonceawait()        //"four" has been processed by onnext()            s1unsubscribe()            //"five" and "six" will not be processed by onnext()            //unblock the observable to continue            oktocontinuecountdown()            w1tjoin()            w2tjoin()        } catch (exception e) {            eprintstacktrace()            fail(egetmessage())        }        inorder inorder  inorder(aobserver)        inorderverify(aobserver times(1))onnext("one")        inorderverify(aobserver times(1))onnext("two")        inorderverify(aobserver times(1))onnext("three")        inorderverify(aobserver times(1))onnext("four")        inorderverify(aobserver never())onnext("five")        inorderverify(aobserver never())onnext("six")        verify(aobserver never())oncompleted()        verify(aobserver never())onerror(any(exceptionclass))```  }on tue apr 2 2013 at 8:55 pm cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #72 > this pull request looks good> > —> reply to this email directly or view it on github  || the rx net version of concat uses the immediatescheduler to execute theoperation which will execute the operation on the same calling thread  soif the observables are running on the same thread it will besynchronous/blocked   i have pulled in your changes from your fork andadded the additional unit test to test unsubscribe() with observablesrunning in different thread  i have also updated the javadoc about theblocking with observable on the same thread  from my side it looks goodon wed apr 3 2013 at 10:20 am billy yuen billyy@gmailcom wrote:> my original test case was intended to test the unsubscribe inside one of> child observable   the countdownlatch was used so that the code will have> a chance to unsubscribe in a predicable manner (unsubscribe after "four")>  in a normal case there should be no blocking between inner and outer> observable  i rewrote the case for better clarity and having the outer> observable is in a separate thread (so the test will pass now)  you> brought up a good point about "when" you can unsubscribe  should it only> allow unsubscribe to happen during the outer onnext()?  i need to do more> research on it  here is the test i plan to add> > ```>     @test> ```> >  public void testconcatunsubscribeobservableofobservable() {> > ```>         final countdownlatch callonce  new countdownlatch(1)> >         final countdownlatch oktocontinue  new countdownlatch(1)> >         final testobservable<string> w1  new testobservable<string>(> ```> > "one" "two" "three")> > ```>         final testobservable<string> w2  newtestobservable<string>(callonce oktocontinue> ```> > "four" "five" "six")> > ```>         @suppresswarnings("unchecked")> >         observer<string> aobserver  mock(observerclass)> >         @suppresswarnings("unchecked")> ```> >    testobservable<observable<string>> observableofobservables  newtestobservable<observable<string>>(w1 w2)> > ```>         func1<observer<string> subscription> concatf > ```> > concat(observableofobservables)> > ```>         observable<string> concat  observablecreate(concatf)> > > >         subscription s1  concatsubscribe(aobserver)> > > >         try {> >             //block main thread to allow observable "w1" to complete> ```> > and observable "w2" to call onnext exactly once> > ```>         callonceawait()> >         //"four" has been processed by onnext()> >             s1unsubscribe()> >             //"five" and "six" will not be processed by onnext()> >             //unblock the observable to continue> >             oktocontinuecountdown()> >             w1tjoin()> >             w2tjoin()> >         } catch (exception e) {> >             eprintstacktrace()> >             fail(egetmessage())> >         }> > >         inorder inorder  inorder(aobserver)> >         inorderverify(aobserver times(1))onnext("one")> >         inorderverify(aobserver times(1))onnext("two")> >         inorderverify(aobserver times(1))onnext("three")> >         inorderverify(aobserver times(1))onnext("four")> >         inorderverify(aobserver never())onnext("five")> >         inorderverify(aobserver never())onnext("six")> >         verify(aobserver never())oncompleted()> >         verify(aobserver never())onerror(any(exceptionclass))> ```> >   }> > on tue apr 2 2013 at 8:55 pm cloudbees pull request builder plugin <> notifications@githubcom> wrote:> > > rxjava-pull-requests #72 > > > this pull request looks good> > > > —> > reply to this email directly or view it on github >  || > i do find it a little strange that observablefrom(iterable) is a "shotgun> observable" ie the subscribe() blocks until all downstream operations> have completed on all items which means it is impossible to ever> unsubscribe() but given that this is correct behavior i think that it> makes sense that concat(o1 o2) also cannot be unsubscribed-from i added a> cautionary comment to the javadocrx does not (or rarely does) add concurrency (see guideline 612) thus `observablefrom` is wrapping a synchronous iterable therefore the observable will be synchronousa `scheduler` could be used to make the subscription to an iterable happen on another thread or a custom `observable` could be created that handles an iterable asynchronouslyall rx operators must be capable of handling both synchronous and asynchronous sequences and if its synchronous that means unsubscribe will not work (which means its up to the implementor of an observable to understand this and decided if its okay to firehose the results)for the case of concat my concern is that if all the sequences being combined are async then we need to retain the async behavior and not block and prevent unsubscriptionfor example:- async or synchronous observablea with 10 items- async or synchronous observableb with 20 items- async observablec with infinite items (hot observable that never completed)i should be able to do this: `concat(a b c)take(50)` this should get the 10 items from a 20 items from b and first 20 items from c and then unsubscribe and continuedoes this work with the current implementation and correctly unsubscribe from observablec? || good point  the best way to tell is to build an unit test for this case i can expand my new test to include this case and see what happenon wed apr 3 2013 at 2:29 pm ben christensen notifications@githubcomwrote:> i do find it a little strange that observablefrom(iterable) is a "shotgun> observable" ie the subscribe() blocks until all downstream operations> have completed on all items which means it is impossible to ever> unsubscribe() but given that this is correct behavior i think that it> makes sense that concat(o1 o2) also cannot be unsubscribed-from i added a> cautionary comment to the javadoc> > rx does not (or rarely does) add concurrency (see guideline 612) thus> observablefrom is wrapping a synchronous iterable therefore the> observable will be synchronous> > a scheduler could be used to make the subscription to an iterable happen> on another thread or a custom observable could be created that handles> an iterable asynchronously> > all rx operators must be capable of handling both synchronous and> asynchronous sequences and if its synchronous that means unsubscribe will> not work (which means its up to the implementor of an observable to> understand this and decided if its okay to firehose the results)> > for the case of concat my concern is that if all the sequences being> combined are async then we need to retain the async behavior and not block> and prevent unsubscription> > for example:> - async or synchronous observablea with 10 items> - async or synchronous observableb with 20 items> - async observablec with infinite items (hot observable that never>   completed)> > i should be able to do this:> > concat(a b c)take(50)> > this should get the 10 items from a 20 items from b and first 20 items> from c and then unsubscribe and continue> > does this work with the current implementation and correctly unsubscribe> from observablec?> > —> reply to this email directly or view it on github  || 
205,1,0,1,0,0,0,1,0,reimplementation of concat improved handling of observable<observable<t >>the old version required all of the observable<t>s to be generated and bufferedbefore the concat could begin  if the outer observable was asynchronous itemscould be dropped (test added)  the new version passes the test and does thebest job i could (after examining several possible strategies) of achievingclear and consistent semantics in accordance with the principle of leastsurprise(my attempt to  #202) #45] there is another issue with this implementation  the countdown latch will always block the calling thread which is not desirable  anything that returns an observable should never be blocking  rx is meant to support composition of operations and allows each operation to run concurrently || while reviewing this i started playing with the unit tests and added 2 new ones i also made them use inorderverify so they ensure correct ordering ive pasted it below so you can merge into your branch instead of me complicating the merge with another branch the tests pass pass except `testconcatunsubscribe` which deadlocks it does this because a list<observable> wont return the subscription asynchronously so it cant unsubscribe meanwhile a countdownlatch is waiting for the change to trigger and the two latches end up waiting on each otheri havent thought through enough yet to determine if there is a way to solve that or if the unit test is just testing the wrong thing and thus a bad testthe comment above from @billy about countdownlatch originated from a discussion between him and i - but while reviewing this it is probably the right approachi was playing with other approaches that are purely non-blocking while retaining the correct concat sequential behavior but they all seem to require either:- another wrapping thread- stealing work from one of the child observable threads and making it do work that is queued on the others  and that seems like a bad idea even though it can be hacked to "work" but it does so in a way that is very unexpected and thus not something i want to pursue- queueing all onnext values which could be a bad memory issue  and also means we eagerly subscribe which is not what we wantmy biggest issue right now is that concat(o1 o2) is a very common usage but that results in list<observable> which will be blocking and unsubscribe doesnt workill think through this more but id appreciate your thoughts on how to handle `testconcatunsubscribe` ``` java    public static class unittest {        @test        public void testconcat() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            @suppresswarnings("unchecked")            observable<string> concat  observablecreate(concat(odds even))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        @test        public void testconcatwithlist() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            final list<observable<string>> list  new arraylist<observable<string>>()            listadd(odds)            listadd(even)            observable<string> concat  observablecreate(concat(list))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        @test        public void testconcatunsubscribe() {            final countdownlatch callonce  new countdownlatch(1)            final countdownlatch oktocontinue  new countdownlatch(1)            final testobservable<string> w1  new testobservable<string>("one" "two" "three")            final testobservable<string> w2  new testobservable<string>(callonce oktocontinue "four" "five" "six")            @suppresswarnings("unchecked")            observer<string> aobserver  mock(observerclass)            @suppresswarnings("unchecked")            observable<string> concat  observablecreate(concat(w1 w2))            systemoutprintln("before subscribe")            subscription s1  concatsubscribe(aobserver)            systemoutprintln("after subscribe")            try {                //block main thread to allow observable "w1" to complete and observable "w2" to call onnext once                systemoutprintln("before callonceawait")                callonceawait()                systemoutprintln("after callonceawait")                s1unsubscribe()                systemoutprintln("after s1unsubscribe")                //unblock the observable to continue                oktocontinuecountdown()                systemoutprintln("after countdown")                w1tjoin()                w2tjoin()            } catch (exception e) {                eprintstacktrace()                fail(egetmessage())            }            inorder inorder  inorder(aobserver)            inorderverify(aobserver times(1))onnext("one")            inorderverify(aobserver times(1))onnext("two")            inorderverify(aobserver times(1))onnext("three")            inorderverify(aobserver times(1))onnext("four")            inorderverify(aobserver never())onnext("five")            inorderverify(aobserver never())onnext("six")            inorderverify(aobserver times(1))oncompleted()        }        @test        public void testmergeobservableofobservables() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {                @override                public subscription call(observer<observable<string>> observer) {                    // simulate what would happen in an observable                    observeronnext(odds)                    observeronnext(even)                    observeroncompleted()                    return new subscription() {                        @override                        public void unsubscribe() {                            // unregister  will never be called here since we are executing synchronously                        }                    }                }            })            observable<string> concat  observablecreate(concat(observableofobservables))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        /**         * simple concat of 2 asynchronous observables ensuring it emits in correct order         */        @suppresswarnings("unchecked")        @test        public void testsimpleasyncconcat() {            observer<string> observer  mock(observerclass)            testobservable<string> o1  new testobservable<string>("one" "two" "three")            testobservable<string> o2  new testobservable<string>("four" "five" "six")            observableconcat(o1 o2)subscribe(observer)            try {                // wait for async observables to complete                o1tjoin()                o2tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads")            }            inorder inorder  inorder(observer)            inorderverify(observer times(1))onnext("one")            inorderverify(observer times(1))onnext("two")            inorderverify(observer times(1))onnext("three")            inorderverify(observer times(1))onnext("four")            inorderverify(observer times(1))onnext("five")            inorderverify(observer times(1))onnext("six")        }        /**         * test an async observable that emits more async observables         */        @suppresswarnings("unchecked")        @test        public void testnestedasyncconcat() throws exception {            observer<string> observer  mock(observerclass)            final testobservable<string> o1  new testobservable<string>("one" "two" "three")            final testobservable<string> o2  new testobservable<string>("four" "five" "six")            final testobservable<string> o3  new testobservable<string>("seven" "eight" "nine")            final countdownlatch allowthird  new countdownlatch(1)            final atomicreference<thread> parent  new atomicreference<thread>()            observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {                @override                public subscription call(final observer<observable<string>> observer) {                    final booleansubscription s  new booleansubscription()                    parentset(new thread(new runnable() {                        @override                        public void run() {                            try {                                // emit first                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o1")                                    observeronnext(o1)                                }                                // emit second                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o2")                                    observeronnext(o2)                                }                                // wait until sometime later and emit third                                try {                                    allowthirdawait()                                } catch (interruptedexception e) {                                    observeronerror(e)                                }                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o3")                                    observeronnext(o3)                                }                            } catch (exception e) {                                observeronerror(e)                            } finally {                                systemoutprintln("done parent observable")                                observeroncompleted()                            }                        }                    }))                    parentget()start()                    return s                }            })            observablecreate(concat(observableofobservables))subscribe(observer)            // wait for parent to start            while (parentget()  null) {                threadsleep(1)            }            try {                // wait for first 2 async observables to complete                while (o1t  null) {                    threadsleep(1)                }                systemoutprintln("thread1 started  waiting for it to complete ")                o1tjoin()                while (o2t  null) {                    threadsleep(1)                }                systemoutprintln("thread2 started  waiting for it to complete ")                o2tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads" e)            }            inorder inorder  inorder(observer)            inorderverify(observer times(1))onnext("one")            inorderverify(observer times(1))onnext("two")            inorderverify(observer times(1))onnext("three")            inorderverify(observer times(1))onnext("four")            inorderverify(observer times(1))onnext("five")            inorderverify(observer times(1))onnext("six")            // we shouldnt have the following 3 yet            inorderverify(observer never())onnext("seven")            inorderverify(observer never())onnext("eight")            inorderverify(observer never())onnext("nine")            // we should not be completed yet            verify(observer never())oncompleted()            verify(observer never())onerror(any(exceptionclass))            // now allow the third            allowthirdcountdown()            try {                while (o3t  null) {                    threadsleep(1)                }                // wait for 3rd to complete                o3tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads" e)            }            inorderverify(observer times(1))onnext("seven")            inorderverify(observer times(1))onnext("eight")            inorderverify(observer times(1))onnext("nine")            inorderverify(observer times(1))oncompleted()            verify(observer never())onerror(any(exceptionclass))        }        @suppresswarnings("unchecked")        @test        public void testblockedobservableofobservables() {            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            final countdownlatch callonce  new countdownlatch(1)            final countdownlatch oktocontinue  new countdownlatch(1)            testobservable<observable<string>> observableofobservables  new testobservable<observable<string>>(callonce oktocontinue odds even)            func1<observer<string> subscription> concatf  concat(observableofobservables)            observable<string> concat  observablecreate(concatf)            concatsubscribe(observer)            try {                //block main thread to allow observables to serve up o1                callonceawait()            } catch (exception ex) {                exprintstacktrace()                fail(exgetmessage())            }            // the concated observable should have served up all of the odds            verify(observer times(1))onnext("1")            verify(observer times(1))onnext("3")            verify(observer times(1))onnext("5")            verify(observer times(1))onnext("7")            try {                // unblock observables so it can serve up o2 and complete                oktocontinuecountdown()                observableofobservablestjoin()            } catch (exception ex) {                exprintstacktrace()                fail(exgetmessage())            }            // the concatenated observable should now have served up all the evens            verify(observer times(1))onnext("2")            verify(observer times(1))onnext("4")            verify(observer times(1))onnext("6")        }        private static class testobservable<t> extends observable<t> {            private final subscription s  new subscription() {                @override                public void unsubscribe() {                    subscribed  false                }            }            private final list<t> values            private thread t  null            private int count  0            private boolean subscribed  true            private final countdownlatch once            private final countdownlatch oktocontinue            public testobservable(t values) {                this(null null values)            }            public testobservable(countdownlatch once countdownlatch oktocontinue t values) {                thisvalues  arraysaslist(values)                thisonce  once                thisoktocontinue  oktocontinue            }            @override            public subscription subscribe(final observer<t> observer) {                t  new thread(new runnable() {                    @override                    public void run() {                        try {                            while (count < valuessize() && subscribed) {                                observeronnext(valuesget(count))                                count++                                //unblock the main thread to call unsubscribe                                if (null ! once)                                    oncecountdown()                                //block until the main thread has called unsubscribe                                if (null ! once)                                    oktocontinueawait()                            }                            if (subscribed)                                observeroncompleted()                        } catch (interruptedexception e) {                            eprintstacktrace()                            fail(egetmessage())                        }                    }                })                tstart()                return s            }        }    }``` || thanks for the comments and the extra tests i have merged them anduploaded a new versionregarding testconcatunsubscribe: im still not entirely sure of my footingbut i believe the test is in error it is demonstrating exactly the issuewhich i mentioned in the new javadoc for operationconcat specifically itsets up a situation wherein the inner observables thread is blocked on theouter observables thread: the inner thread cannot proceed until the testcalls oktocontinuecountdown() which happens-afterconcatsubscribe(aobserver) which blocks until the list has delivered bothw1 and w2am i right that in general an observer should block onnext() until it hasfinished processing the item? this pushes the flow-control upstream ratherthan excessive buffering or throttling (which can be done explicitly in theoperation-chain if desired) if thats right then i think concat mustblock the outer onnext until it has finished servicing the inner sequencei do find it a little strange that observablefrom(iterable) is a "shotgunobservable" ie the subscribe() blocks until all downstream operationshave completed on all items which means it is impossible to everunsubscribe() but given that this is correct behavior i think that itmakes sense that concat(o1 o2) also cannot be unsubscribed-from i added acautionary comment to the javadoci have updated the test case to call concatsubscribe(aobserver) in abackground thread which fixes the deadlock and to expect all items to bedelivered despite an unsubscribe which makes the test pass(i had also tried those three non-blocking approaches before uploading thisversion thanks for checking my work :)on mar 27 2013 6:56 am "ben christensen" notifications@githubcom wrote:> while reviewing this i started playing with the unit tests and added 2 new> ones i also made them use inorderverify so they ensure correct ordering> ive pasted it below so you can merge into your branch instead of me> complicating the merge with another branch> > the tests pass pass except testconcatunsubscribe which deadlocks it does> this because a list wont return the subscription asynchronously so it> cant unsubscribe meanwhile a countdownlatch is waiting for the change to> trigger and the two latches end up waiting on each other> > i havent thought through enough yet to determine if there is a way to> solve that or if the unit test is just testing the wrong thing and thus a> bad test> > the comment above from @billy  about> countdownlatch originated from a discussion between him and i - but while> reviewing this it is probably the right approach> > i was playing with other approaches that are purely non-blocking while> retaining the correct concat sequential behavior but they all seem to> require either:> - another wrapping thread> - stealing work from one of the child observable threads and making it>   do work that is queued on the others  and that seems like a bad idea>   even though it can be hacked to "work" but it does so in a way that is very>   unexpected and thus not something i want to pursue> - queueing all onnext values which could be a bad memory issue  and>   also means we eagerly subscribe which is not what we want> > my biggest issue right now is that concat(o1 o2) is a very common usage> but that results in list which will be blocking and unsubscribe doesnt> work> > ill think through this more but id appreciate your thoughts on how to> handle testconcatunsubscribe> > ```> public static class unittest {> >     @test>     public void testconcat() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string o  { "1" "3" "5" "7" }>         final string e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)> >         @suppresswarnings("unchecked")>         observable<string> concat  observablecreate(concat(odds even))>         concatsubscribe(observer)> >         verify(observer times(7))onnext(anystring())>     }> >     @test>     public void testconcatwithlist() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)>         final list<observable<string>> list  new arraylist<observable<string>>()>         listadd(odds)>         listadd(even)>         observable<string> concat  observablecreate(concat(list))>         concatsubscribe(observer)> >         verify(observer times(7))onnext(anystring())>     }> >     @test>     public void testconcatunsubscribe() {>         final countdownlatch callonce  new countdownlatch(1)>         final countdownlatch oktocontinue  new countdownlatch(1)>         final testobservable<string> w1  new testobservable<string>("one" "two" "three")>         final testobservable<string> w2  new testobservable<string>(callonce oktocontinue "four" "five" "six")> >         @suppresswarnings("unchecked")>         observer<string> aobserver  mock(observerclass)>         @suppresswarnings("unchecked")>         observable<string> concat  observablecreate(concat(w1 w2))>         systemoutprintln("before subscribe")>         subscription s1  concatsubscribe(aobserver)>         systemoutprintln("after subscribe")>         try {>             //block main thread to allow observable "w1" to complete and observable "w2" to call onnext once>             systemoutprintln("before callonceawait")>             callonceawait()>             systemoutprintln("after callonceawait")>             s1unsubscribe()>             systemoutprintln("after s1unsubscribe")>             //unblock the observable to continue>             oktocontinuecountdown()>             systemoutprintln("after countdown")>             w1tjoin()>             w2tjoin()>         } catch (exception e) {>             eprintstacktrace()>             fail(egetmessage())>         }> >         inorder inorder  inorder(aobserver)>         inorderverify(aobserver times(1))onnext("one")>         inorderverify(aobserver times(1))onnext("two")>         inorderverify(aobserver times(1))onnext("three")>         inorderverify(aobserver times(1))onnext("four")>         inorderverify(aobserver never())onnext("five")>         inorderverify(aobserver never())onnext("six")>         inorderverify(aobserver times(1))oncompleted()>     }> >     @test>     public void testmergeobservableofobservables() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)> >         observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {> >             @override>             public subscription call(observer<observable<string>> observer) {>                 // simulate what would happen in an observable>                 observeronnext(odds)>                 observeronnext(even)>                 observeroncompleted()> >                 return new subscription() {> >                     @override>                     public void unsubscribe() {>                         // unregister  will never be called here since we are executing synchronously>                     }> >                 }>             }> >         })>         observable<string> concat  observablecreate(concat(observableofobservables))>         concatsubscribe(observer)>         verify(observer times(7))onnext(anystring())>     }> >     /**         * simple concat of 2 asynchronous observables ensuring it emits in correct order         */>     @suppresswarnings("unchecked")>     @test>     public void testsimpleasyncconcat() {>         observer<string> observer  mock(observerclass)> >         testobservable<string> o1  new testobservable<string>("one" "two" "three")>         testobservable<string> o2  new testobservable<string>("four" "five" "six")> >         observableconcat(o1 o2)subscribe(observer)> >         try {>             // wait for async observables to complete>             o1tjoin()>             o2tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads")>         }> >         inorder inorder  inorder(observer)>         inorderverify(observer times(1))onnext("one")>         inorderverify(observer times(1))onnext("two")>         inorderverify(observer times(1))onnext("three")>         inorderverify(observer times(1))onnext("four")>         inorderverify(observer times(1))onnext("five")>         inorderverify(observer times(1))onnext("six")>     }> >     /**         * test an async observable that emits more async observables         */>     @suppresswarnings("unchecked")>     @test>     public void testnestedasyncconcat() throws exception {>         observer<string> observer  mock(observerclass)> >         final testobservable<string> o1  new testobservable<string>("one" "two" "three")>         final testobservable<string> o2  new testobservable<string>("four" "five" "six")>         final testobservable<string> o3  new testobservable<string>("seven" "eight" "nine")>         final countdownlatch allowthird  new countdownlatch(1)> >         final atomicreference<thread> parent  new atomicreference<thread>()>         observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {> >             @override>             public subscription call(final observer<observable<string>> observer) {>                 final booleansubscription s  new booleansubscription()>                 parentset(new thread(new runnable() {> >                     @override>                     public void run() {>                         try {>                             // emit first>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o1")>                                 observeronnext(o1)>                             }>                             // emit second>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o2")>                                 observeronnext(o2)>                             }> >                             // wait until sometime later and emit third>                             try {>                                 allowthirdawait()>                             } catch (interruptedexception e) {>                                 observeronerror(e)>                             }>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o3")>                                 observeronnext(o3)>                             }> >                         } catch (exception e) {>                             observeronerror(e)>                         } finally {>                             systemoutprintln("done parent observable")>                             observeroncompleted()>                         }>                     }>                 }))>                 parentget()start()>                 return s>             }>         })> >         observablecreate(concat(observableofobservables))subscribe(observer)> >         // wait for parent to start>         while (parentget()  null) {>             threadsleep(1)>         }> >         try {>             // wait for first 2 async observables to complete>             while (o1t  null) {>                 threadsleep(1)>             }>             systemoutprintln("thread1 started  waiting for it to complete ")>             o1tjoin()>             while (o2t  null) {>                 threadsleep(1)>             }>             systemoutprintln("thread2 started  waiting for it to complete ")>             o2tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads" e)>         }> >         inorder inorder  inorder(observer)>         inorderverify(observer times(1))onnext("one")>         inorderverify(observer times(1))onnext("two")>         inorderverify(observer times(1))onnext("three")>         inorderverify(observer times(1))onnext("four")>         inorderverify(observer times(1))onnext("five")>         inorderverify(observer times(1))onnext("six")>         // we shouldnt have the following 3 yet>         inorderverify(observer never())onnext("seven")>         inorderverify(observer never())onnext("eight")>         inorderverify(observer never())onnext("nine")>         // we should not be completed yet>         verify(observer never())oncompleted()>         verify(observer never())onerror(any(exceptionclass))> >         // now allow the third>         allowthirdcountdown()> >         try {>             while (o3t  null) {>                 threadsleep(1)>             }>             // wait for 3rd to complete>             o3tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads" e)>         }> >         inorderverify(observer times(1))onnext("seven")>         inorderverify(observer times(1))onnext("eight")>         inorderverify(observer times(1))onnext("nine")> >         inorderverify(observer times(1))oncompleted()>         verify(observer never())onerror(any(exceptionclass))>     }> >     @suppresswarnings("unchecked")>     @test>     public void testblockedobservableofobservables() {>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }>         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)>         final countdownlatch callonce  new countdownlatch(1)>         final countdownlatch oktocontinue  new countdownlatch(1)>         testobservable<observable<string>> observableofobservables  new testobservable<observable<string>>(callonce oktocontinue odds even)>         func1<observer<string> subscription> concatf  concat(observableofobservables)>         observable<string> concat  observablecreate(concatf)>         concatsubscribe(observer)>         try {>             //block main thread to allow observables to serve up o1>             callonceawait()>         } catch (exception ex) {>             exprintstacktrace()>             fail(exgetmessage())>         }>         // the concated observable should have served up all of the odds>         verify(observer times(1))onnext("1")>         verify(observer times(1))onnext("3")>         verify(observer times(1))onnext("5")>         verify(observer times(1))onnext("7")> >         try {>             // unblock observables so it can serve up o2 and complete>             oktocontinuecountdown()>             observableofobservablestjoin()>         } catch (exception ex) {>             exprintstacktrace()>             fail(exgetmessage())>         }>         // the concatenated observable should now have served up all the evens>         verify(observer times(1))onnext("2")>         verify(observer times(1))onnext("4")>         verify(observer times(1))onnext("6")>     }> >     private static class testobservable<t> extends observable<t> {> >         private final subscription s  new subscription() {> >             @override>             public void unsubscribe() {>                 subscribed  false>             }> >         }>         private final list<t> values>         private thread t  null>         private int count  0>         private boolean subscribed  true>         private final countdownlatch once>         private final countdownlatch oktocontinue> >         public testobservable(t values) {>             this(null null values)>         }> >         public testobservable(countdownlatch once countdownlatch oktocontinue t values) {>             thisvalues  arraysaslist(values)>             thisonce  once>             thisoktocontinue  oktocontinue>         }> >         @override>         public subscription subscribe(final observer<t> observer) {>             t  new thread(new runnable() {> >                 @override>                 public void run() {>                     try {>                         while (count < valuessize() && subscribed) {>                             observeronnext(valuesget(count))>                             count++>                             //unblock the main thread to call unsubscribe>                             if (null ! once)>                                 oncecountdown()>                             //block until the main thread has called unsubscribe>                             if (null ! once)>                                 oktocontinueawait()>                         }>                         if (subscribed)>                             observeroncompleted()>                     } catch (interruptedexception e) {>                         eprintstacktrace()>                         fail(egetmessage())>                     }>                 }> >             })>             tstart()>             return s>         }> >     }> > }> ```> > > reply to this email directly or view it on github  || #59  #60 thanks for update  let me take a look and i will do some moreresearch/thought on the testconcatsubscribe test caseon fri mar 29 2013 at 2:22 am cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #60 > this pull request looks good> > —> reply to this email directly or view it on github  || [rxjava-pull-requests #72 looks good || my original test case was intended to test the unsubscribe inside one ofchild observable   the countdownlatch was used so that the code will havea chance to unsubscribe in a predicable manner (unsubscribe after "four") in a normal case there should be no blocking between inner and outerobservable  i rewrote the case for better clarity and having the outerobservable is in a separate thread (so the test will pass now)  youbrought up a good point about "when" you can unsubscribe  should it onlyallow unsubscribe to happen during the outer onnext()?  i need to do moreresearch on it  here is the test i plan to add```    @test``` public void testconcatunsubscribeobservableofobservable() {```        final countdownlatch callonce  new countdownlatch(1)        final countdownlatch oktocontinue  new countdownlatch(1)        final testobservable<string> w1  new testobservable<string>(```"one" "two" "three")```        final testobservable<string> w2 ```newtestobservable<string>(callonce oktocontinue"four" "five" "six")```        @suppresswarnings("unchecked")        observer<string> aobserver  mock(observerclass)        @suppresswarnings("unchecked")```   testobservable<observable<string>> observableofobservables newtestobservable<observable<string>>(w1 w2)```        func1<observer<string> subscription> concatf ```concat(observableofobservables)```        observable<string> concat  observablecreate(concatf)        subscription s1  concatsubscribe(aobserver)        try {            //block main thread to allow observable "w1" to complete```and observable "w2" to call onnext exactly once```        callonceawait()        //"four" has been processed by onnext()            s1unsubscribe()            //"five" and "six" will not be processed by onnext()            //unblock the observable to continue            oktocontinuecountdown()            w1tjoin()            w2tjoin()        } catch (exception e) {            eprintstacktrace()            fail(egetmessage())        }        inorder inorder  inorder(aobserver)        inorderverify(aobserver times(1))onnext("one")        inorderverify(aobserver times(1))onnext("two")        inorderverify(aobserver times(1))onnext("three")        inorderverify(aobserver times(1))onnext("four")        inorderverify(aobserver never())onnext("five")        inorderverify(aobserver never())onnext("six")        verify(aobserver never())oncompleted()        verify(aobserver never())onerror(any(exceptionclass))```  }on tue apr 2 2013 at 8:55 pm cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #72 > this pull request looks good> > —> reply to this email directly or view it on github  || the rx net version of concat uses the immediatescheduler to execute theoperation which will execute the operation on the same calling thread  soif the observables are running on the same thread it will besynchronous/blocked   i have pulled in your changes from your fork andadded the additional unit test to test unsubscribe() with observablesrunning in different thread  i have also updated the javadoc about theblocking with observable on the same thread  from my side it looks goodon wed apr 3 2013 at 10:20 am billy yuen billyy@gmailcom wrote:> my original test case was intended to test the unsubscribe inside one of> child observable   the countdownlatch was used so that the code will have> a chance to unsubscribe in a predicable manner (unsubscribe after "four")>  in a normal case there should be no blocking between inner and outer> observable  i rewrote the case for better clarity and having the outer> observable is in a separate thread (so the test will pass now)  you> brought up a good point about "when" you can unsubscribe  should it only> allow unsubscribe to happen during the outer onnext()?  i need to do more> research on it  here is the test i plan to add> > ```>     @test> ```> >  public void testconcatunsubscribeobservableofobservable() {> > ```>         final countdownlatch callonce  new countdownlatch(1)> >         final countdownlatch oktocontinue  new countdownlatch(1)> >         final testobservable<string> w1  new testobservable<string>(> ```> > "one" "two" "three")> > ```>         final testobservable<string> w2  newtestobservable<string>(callonce oktocontinue> ```> > "four" "five" "six")> > ```>         @suppresswarnings("unchecked")> >         observer<string> aobserver  mock(observerclass)> >         @suppresswarnings("unchecked")> ```> >    testobservable<observable<string>> observableofobservables  newtestobservable<observable<string>>(w1 w2)> > ```>         func1<observer<string> subscription> concatf > ```> > concat(observableofobservables)> > ```>         observable<string> concat  observablecreate(concatf)> > > >         subscription s1  concatsubscribe(aobserver)> > > >         try {> >             //block main thread to allow observable "w1" to complete> ```> > and observable "w2" to call onnext exactly once> > ```>         callonceawait()> >         //"four" has been processed by onnext()> >             s1unsubscribe()> >             //"five" and "six" will not be processed by onnext()> >             //unblock the observable to continue> >             oktocontinuecountdown()> >             w1tjoin()> >             w2tjoin()> >         } catch (exception e) {> >             eprintstacktrace()> >             fail(egetmessage())> >         }> > >         inorder inorder  inorder(aobserver)> >         inorderverify(aobserver times(1))onnext("one")> >         inorderverify(aobserver times(1))onnext("two")> >         inorderverify(aobserver times(1))onnext("three")> >         inorderverify(aobserver times(1))onnext("four")> >         inorderverify(aobserver never())onnext("five")> >         inorderverify(aobserver never())onnext("six")> >         verify(aobserver never())oncompleted()> >         verify(aobserver never())onerror(any(exceptionclass))> ```> >   }> > on tue apr 2 2013 at 8:55 pm cloudbees pull request builder plugin <> notifications@githubcom> wrote:> > > rxjava-pull-requests #72 > > > this pull request looks good> > > > —> > reply to this email directly or view it on github >  || > i do find it a little strange that observablefrom(iterable) is a "shotgun> observable" ie the subscribe() blocks until all downstream operations> have completed on all items which means it is impossible to ever> unsubscribe() but given that this is correct behavior i think that it> makes sense that concat(o1 o2) also cannot be unsubscribed-from i added a> cautionary comment to the javadocrx does not (or rarely does) add concurrency (see guideline 612) thus `observablefrom` is wrapping a synchronous iterable therefore the observable will be synchronousa `scheduler` could be used to make the subscription to an iterable happen on another thread or a custom `observable` could be created that handles an iterable asynchronouslyall rx operators must be capable of handling both synchronous and asynchronous sequences and if its synchronous that means unsubscribe will not work (which means its up to the implementor of an observable to understand this and decided if its okay to firehose the results)for the case of concat my concern is that if all the sequences being combined are async then we need to retain the async behavior and not block and prevent unsubscriptionfor example:- async or synchronous observablea with 10 items- async or synchronous observableb with 20 items- async observablec with infinite items (hot observable that never completed)i should be able to do this: `concat(a b c)take(50)` this should get the 10 items from a 20 items from b and first 20 items from c and then unsubscribe and continuedoes this work with the current implementation and correctly unsubscribe from observablec? || good point  the best way to tell is to build an unit test for this case i can expand my new test to include this case and see what happenon wed apr 3 2013 at 2:29 pm ben christensen notifications@githubcomwrote:> i do find it a little strange that observablefrom(iterable) is a "shotgun> observable" ie the subscribe() blocks until all downstream operations> have completed on all items which means it is impossible to ever> unsubscribe() but given that this is correct behavior i think that it> makes sense that concat(o1 o2) also cannot be unsubscribed-from i added a> cautionary comment to the javadoc> > rx does not (or rarely does) add concurrency (see guideline 612) thus> observablefrom is wrapping a synchronous iterable therefore the> observable will be synchronous> > a scheduler could be used to make the subscription to an iterable happen> on another thread or a custom observable could be created that handles> an iterable asynchronously> > all rx operators must be capable of handling both synchronous and> asynchronous sequences and if its synchronous that means unsubscribe will> not work (which means its up to the implementor of an observable to> understand this and decided if its okay to firehose the results)> > for the case of concat my concern is that if all the sequences being> combined are async then we need to retain the async behavior and not block> and prevent unsubscription> > for example:> - async or synchronous observablea with 10 items> - async or synchronous observableb with 20 items> - async observablec with infinite items (hot observable that never>   completed)> > i should be able to do this:> > concat(a b c)take(50)> > this should get the 10 items from a 20 items from b and first 20 items> from c and then unsubscribe and continue> > does this work with the current implementation and correctly unsubscribe> from observablec?> > —> reply to this email directly or view it on github  || 
205,1,0,0,0,0,0,1,0,reimplementation of concat improved handling of observable<observable<t >>the old version required all of the observable<t>s to be generated and bufferedbefore the concat could begin  if the outer observable was asynchronous itemscould be dropped (test added)  the new version passes the test and does thebest job i could (after examining several possible strategies) of achievingclear and consistent semantics in accordance with the principle of leastsurprise(my attempt to  #202) #45] there is another issue with this implementation  the countdown latch will always block the calling thread which is not desirable  anything that returns an observable should never be blocking  rx is meant to support composition of operations and allows each operation to run concurrently || while reviewing this i started playing with the unit tests and added 2 new ones i also made them use inorderverify so they ensure correct ordering ive pasted it below so you can merge into your branch instead of me complicating the merge with another branch the tests pass pass except `testconcatunsubscribe` which deadlocks it does this because a list<observable> wont return the subscription asynchronously so it cant unsubscribe meanwhile a countdownlatch is waiting for the change to trigger and the two latches end up waiting on each otheri havent thought through enough yet to determine if there is a way to solve that or if the unit test is just testing the wrong thing and thus a bad testthe comment above from @billy about countdownlatch originated from a discussion between him and i - but while reviewing this it is probably the right approachi was playing with other approaches that are purely non-blocking while retaining the correct concat sequential behavior but they all seem to require either:- another wrapping thread- stealing work from one of the child observable threads and making it do work that is queued on the others  and that seems like a bad idea even though it can be hacked to "work" but it does so in a way that is very unexpected and thus not something i want to pursue- queueing all onnext values which could be a bad memory issue  and also means we eagerly subscribe which is not what we wantmy biggest issue right now is that concat(o1 o2) is a very common usage but that results in list<observable> which will be blocking and unsubscribe doesnt workill think through this more but id appreciate your thoughts on how to handle `testconcatunsubscribe` ``` java    public static class unittest {        @test        public void testconcat() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            @suppresswarnings("unchecked")            observable<string> concat  observablecreate(concat(odds even))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        @test        public void testconcatwithlist() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            final list<observable<string>> list  new arraylist<observable<string>>()            listadd(odds)            listadd(even)            observable<string> concat  observablecreate(concat(list))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        @test        public void testconcatunsubscribe() {            final countdownlatch callonce  new countdownlatch(1)            final countdownlatch oktocontinue  new countdownlatch(1)            final testobservable<string> w1  new testobservable<string>("one" "two" "three")            final testobservable<string> w2  new testobservable<string>(callonce oktocontinue "four" "five" "six")            @suppresswarnings("unchecked")            observer<string> aobserver  mock(observerclass)            @suppresswarnings("unchecked")            observable<string> concat  observablecreate(concat(w1 w2))            systemoutprintln("before subscribe")            subscription s1  concatsubscribe(aobserver)            systemoutprintln("after subscribe")            try {                //block main thread to allow observable "w1" to complete and observable "w2" to call onnext once                systemoutprintln("before callonceawait")                callonceawait()                systemoutprintln("after callonceawait")                s1unsubscribe()                systemoutprintln("after s1unsubscribe")                //unblock the observable to continue                oktocontinuecountdown()                systemoutprintln("after countdown")                w1tjoin()                w2tjoin()            } catch (exception e) {                eprintstacktrace()                fail(egetmessage())            }            inorder inorder  inorder(aobserver)            inorderverify(aobserver times(1))onnext("one")            inorderverify(aobserver times(1))onnext("two")            inorderverify(aobserver times(1))onnext("three")            inorderverify(aobserver times(1))onnext("four")            inorderverify(aobserver never())onnext("five")            inorderverify(aobserver never())onnext("six")            inorderverify(aobserver times(1))oncompleted()        }        @test        public void testmergeobservableofobservables() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {                @override                public subscription call(observer<observable<string>> observer) {                    // simulate what would happen in an observable                    observeronnext(odds)                    observeronnext(even)                    observeroncompleted()                    return new subscription() {                        @override                        public void unsubscribe() {                            // unregister  will never be called here since we are executing synchronously                        }                    }                }            })            observable<string> concat  observablecreate(concat(observableofobservables))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        /**         * simple concat of 2 asynchronous observables ensuring it emits in correct order         */        @suppresswarnings("unchecked")        @test        public void testsimpleasyncconcat() {            observer<string> observer  mock(observerclass)            testobservable<string> o1  new testobservable<string>("one" "two" "three")            testobservable<string> o2  new testobservable<string>("four" "five" "six")            observableconcat(o1 o2)subscribe(observer)            try {                // wait for async observables to complete                o1tjoin()                o2tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads")            }            inorder inorder  inorder(observer)            inorderverify(observer times(1))onnext("one")            inorderverify(observer times(1))onnext("two")            inorderverify(observer times(1))onnext("three")            inorderverify(observer times(1))onnext("four")            inorderverify(observer times(1))onnext("five")            inorderverify(observer times(1))onnext("six")        }        /**         * test an async observable that emits more async observables         */        @suppresswarnings("unchecked")        @test        public void testnestedasyncconcat() throws exception {            observer<string> observer  mock(observerclass)            final testobservable<string> o1  new testobservable<string>("one" "two" "three")            final testobservable<string> o2  new testobservable<string>("four" "five" "six")            final testobservable<string> o3  new testobservable<string>("seven" "eight" "nine")            final countdownlatch allowthird  new countdownlatch(1)            final atomicreference<thread> parent  new atomicreference<thread>()            observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {                @override                public subscription call(final observer<observable<string>> observer) {                    final booleansubscription s  new booleansubscription()                    parentset(new thread(new runnable() {                        @override                        public void run() {                            try {                                // emit first                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o1")                                    observeronnext(o1)                                }                                // emit second                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o2")                                    observeronnext(o2)                                }                                // wait until sometime later and emit third                                try {                                    allowthirdawait()                                } catch (interruptedexception e) {                                    observeronerror(e)                                }                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o3")                                    observeronnext(o3)                                }                            } catch (exception e) {                                observeronerror(e)                            } finally {                                systemoutprintln("done parent observable")                                observeroncompleted()                            }                        }                    }))                    parentget()start()                    return s                }            })            observablecreate(concat(observableofobservables))subscribe(observer)            // wait for parent to start            while (parentget()  null) {                threadsleep(1)            }            try {                // wait for first 2 async observables to complete                while (o1t  null) {                    threadsleep(1)                }                systemoutprintln("thread1 started  waiting for it to complete ")                o1tjoin()                while (o2t  null) {                    threadsleep(1)                }                systemoutprintln("thread2 started  waiting for it to complete ")                o2tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads" e)            }            inorder inorder  inorder(observer)            inorderverify(observer times(1))onnext("one")            inorderverify(observer times(1))onnext("two")            inorderverify(observer times(1))onnext("three")            inorderverify(observer times(1))onnext("four")            inorderverify(observer times(1))onnext("five")            inorderverify(observer times(1))onnext("six")            // we shouldnt have the following 3 yet            inorderverify(observer never())onnext("seven")            inorderverify(observer never())onnext("eight")            inorderverify(observer never())onnext("nine")            // we should not be completed yet            verify(observer never())oncompleted()            verify(observer never())onerror(any(exceptionclass))            // now allow the third            allowthirdcountdown()            try {                while (o3t  null) {                    threadsleep(1)                }                // wait for 3rd to complete                o3tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads" e)            }            inorderverify(observer times(1))onnext("seven")            inorderverify(observer times(1))onnext("eight")            inorderverify(observer times(1))onnext("nine")            inorderverify(observer times(1))oncompleted()            verify(observer never())onerror(any(exceptionclass))        }        @suppresswarnings("unchecked")        @test        public void testblockedobservableofobservables() {            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            final countdownlatch callonce  new countdownlatch(1)            final countdownlatch oktocontinue  new countdownlatch(1)            testobservable<observable<string>> observableofobservables  new testobservable<observable<string>>(callonce oktocontinue odds even)            func1<observer<string> subscription> concatf  concat(observableofobservables)            observable<string> concat  observablecreate(concatf)            concatsubscribe(observer)            try {                //block main thread to allow observables to serve up o1                callonceawait()            } catch (exception ex) {                exprintstacktrace()                fail(exgetmessage())            }            // the concated observable should have served up all of the odds            verify(observer times(1))onnext("1")            verify(observer times(1))onnext("3")            verify(observer times(1))onnext("5")            verify(observer times(1))onnext("7")            try {                // unblock observables so it can serve up o2 and complete                oktocontinuecountdown()                observableofobservablestjoin()            } catch (exception ex) {                exprintstacktrace()                fail(exgetmessage())            }            // the concatenated observable should now have served up all the evens            verify(observer times(1))onnext("2")            verify(observer times(1))onnext("4")            verify(observer times(1))onnext("6")        }        private static class testobservable<t> extends observable<t> {            private final subscription s  new subscription() {                @override                public void unsubscribe() {                    subscribed  false                }            }            private final list<t> values            private thread t  null            private int count  0            private boolean subscribed  true            private final countdownlatch once            private final countdownlatch oktocontinue            public testobservable(t values) {                this(null null values)            }            public testobservable(countdownlatch once countdownlatch oktocontinue t values) {                thisvalues  arraysaslist(values)                thisonce  once                thisoktocontinue  oktocontinue            }            @override            public subscription subscribe(final observer<t> observer) {                t  new thread(new runnable() {                    @override                    public void run() {                        try {                            while (count < valuessize() && subscribed) {                                observeronnext(valuesget(count))                                count++                                //unblock the main thread to call unsubscribe                                if (null ! once)                                    oncecountdown()                                //block until the main thread has called unsubscribe                                if (null ! once)                                    oktocontinueawait()                            }                            if (subscribed)                                observeroncompleted()                        } catch (interruptedexception e) {                            eprintstacktrace()                            fail(egetmessage())                        }                    }                })                tstart()                return s            }        }    }``` || thanks for the comments and the extra tests i have merged them anduploaded a new versionregarding testconcatunsubscribe: im still not entirely sure of my footingbut i believe the test is in error it is demonstrating exactly the issuewhich i mentioned in the new javadoc for operationconcat specifically itsets up a situation wherein the inner observables thread is blocked on theouter observables thread: the inner thread cannot proceed until the testcalls oktocontinuecountdown() which happens-afterconcatsubscribe(aobserver) which blocks until the list has delivered bothw1 and w2am i right that in general an observer should block onnext() until it hasfinished processing the item? this pushes the flow-control upstream ratherthan excessive buffering or throttling (which can be done explicitly in theoperation-chain if desired) if thats right then i think concat mustblock the outer onnext until it has finished servicing the inner sequencei do find it a little strange that observablefrom(iterable) is a "shotgunobservable" ie the subscribe() blocks until all downstream operationshave completed on all items which means it is impossible to everunsubscribe() but given that this is correct behavior i think that itmakes sense that concat(o1 o2) also cannot be unsubscribed-from i added acautionary comment to the javadoci have updated the test case to call concatsubscribe(aobserver) in abackground thread which fixes the deadlock and to expect all items to bedelivered despite an unsubscribe which makes the test pass(i had also tried those three non-blocking approaches before uploading thisversion thanks for checking my work :)on mar 27 2013 6:56 am "ben christensen" notifications@githubcom wrote:> while reviewing this i started playing with the unit tests and added 2 new> ones i also made them use inorderverify so they ensure correct ordering> ive pasted it below so you can merge into your branch instead of me> complicating the merge with another branch> > the tests pass pass except testconcatunsubscribe which deadlocks it does> this because a list wont return the subscription asynchronously so it> cant unsubscribe meanwhile a countdownlatch is waiting for the change to> trigger and the two latches end up waiting on each other> > i havent thought through enough yet to determine if there is a way to> solve that or if the unit test is just testing the wrong thing and thus a> bad test> > the comment above from @billy  about> countdownlatch originated from a discussion between him and i - but while> reviewing this it is probably the right approach> > i was playing with other approaches that are purely non-blocking while> retaining the correct concat sequential behavior but they all seem to> require either:> - another wrapping thread> - stealing work from one of the child observable threads and making it>   do work that is queued on the others  and that seems like a bad idea>   even though it can be hacked to "work" but it does so in a way that is very>   unexpected and thus not something i want to pursue> - queueing all onnext values which could be a bad memory issue  and>   also means we eagerly subscribe which is not what we want> > my biggest issue right now is that concat(o1 o2) is a very common usage> but that results in list which will be blocking and unsubscribe doesnt> work> > ill think through this more but id appreciate your thoughts on how to> handle testconcatunsubscribe> > ```> public static class unittest {> >     @test>     public void testconcat() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string o  { "1" "3" "5" "7" }>         final string e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)> >         @suppresswarnings("unchecked")>         observable<string> concat  observablecreate(concat(odds even))>         concatsubscribe(observer)> >         verify(observer times(7))onnext(anystring())>     }> >     @test>     public void testconcatwithlist() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)>         final list<observable<string>> list  new arraylist<observable<string>>()>         listadd(odds)>         listadd(even)>         observable<string> concat  observablecreate(concat(list))>         concatsubscribe(observer)> >         verify(observer times(7))onnext(anystring())>     }> >     @test>     public void testconcatunsubscribe() {>         final countdownlatch callonce  new countdownlatch(1)>         final countdownlatch oktocontinue  new countdownlatch(1)>         final testobservable<string> w1  new testobservable<string>("one" "two" "three")>         final testobservable<string> w2  new testobservable<string>(callonce oktocontinue "four" "five" "six")> >         @suppresswarnings("unchecked")>         observer<string> aobserver  mock(observerclass)>         @suppresswarnings("unchecked")>         observable<string> concat  observablecreate(concat(w1 w2))>         systemoutprintln("before subscribe")>         subscription s1  concatsubscribe(aobserver)>         systemoutprintln("after subscribe")>         try {>             //block main thread to allow observable "w1" to complete and observable "w2" to call onnext once>             systemoutprintln("before callonceawait")>             callonceawait()>             systemoutprintln("after callonceawait")>             s1unsubscribe()>             systemoutprintln("after s1unsubscribe")>             //unblock the observable to continue>             oktocontinuecountdown()>             systemoutprintln("after countdown")>             w1tjoin()>             w2tjoin()>         } catch (exception e) {>             eprintstacktrace()>             fail(egetmessage())>         }> >         inorder inorder  inorder(aobserver)>         inorderverify(aobserver times(1))onnext("one")>         inorderverify(aobserver times(1))onnext("two")>         inorderverify(aobserver times(1))onnext("three")>         inorderverify(aobserver times(1))onnext("four")>         inorderverify(aobserver never())onnext("five")>         inorderverify(aobserver never())onnext("six")>         inorderverify(aobserver times(1))oncompleted()>     }> >     @test>     public void testmergeobservableofobservables() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)> >         observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {> >             @override>             public subscription call(observer<observable<string>> observer) {>                 // simulate what would happen in an observable>                 observeronnext(odds)>                 observeronnext(even)>                 observeroncompleted()> >                 return new subscription() {> >                     @override>                     public void unsubscribe() {>                         // unregister  will never be called here since we are executing synchronously>                     }> >                 }>             }> >         })>         observable<string> concat  observablecreate(concat(observableofobservables))>         concatsubscribe(observer)>         verify(observer times(7))onnext(anystring())>     }> >     /**         * simple concat of 2 asynchronous observables ensuring it emits in correct order         */>     @suppresswarnings("unchecked")>     @test>     public void testsimpleasyncconcat() {>         observer<string> observer  mock(observerclass)> >         testobservable<string> o1  new testobservable<string>("one" "two" "three")>         testobservable<string> o2  new testobservable<string>("four" "five" "six")> >         observableconcat(o1 o2)subscribe(observer)> >         try {>             // wait for async observables to complete>             o1tjoin()>             o2tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads")>         }> >         inorder inorder  inorder(observer)>         inorderverify(observer times(1))onnext("one")>         inorderverify(observer times(1))onnext("two")>         inorderverify(observer times(1))onnext("three")>         inorderverify(observer times(1))onnext("four")>         inorderverify(observer times(1))onnext("five")>         inorderverify(observer times(1))onnext("six")>     }> >     /**         * test an async observable that emits more async observables         */>     @suppresswarnings("unchecked")>     @test>     public void testnestedasyncconcat() throws exception {>         observer<string> observer  mock(observerclass)> >         final testobservable<string> o1  new testobservable<string>("one" "two" "three")>         final testobservable<string> o2  new testobservable<string>("four" "five" "six")>         final testobservable<string> o3  new testobservable<string>("seven" "eight" "nine")>         final countdownlatch allowthird  new countdownlatch(1)> >         final atomicreference<thread> parent  new atomicreference<thread>()>         observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {> >             @override>             public subscription call(final observer<observable<string>> observer) {>                 final booleansubscription s  new booleansubscription()>                 parentset(new thread(new runnable() {> >                     @override>                     public void run() {>                         try {>                             // emit first>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o1")>                                 observeronnext(o1)>                             }>                             // emit second>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o2")>                                 observeronnext(o2)>                             }> >                             // wait until sometime later and emit third>                             try {>                                 allowthirdawait()>                             } catch (interruptedexception e) {>                                 observeronerror(e)>                             }>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o3")>                                 observeronnext(o3)>                             }> >                         } catch (exception e) {>                             observeronerror(e)>                         } finally {>                             systemoutprintln("done parent observable")>                             observeroncompleted()>                         }>                     }>                 }))>                 parentget()start()>                 return s>             }>         })> >         observablecreate(concat(observableofobservables))subscribe(observer)> >         // wait for parent to start>         while (parentget()  null) {>             threadsleep(1)>         }> >         try {>             // wait for first 2 async observables to complete>             while (o1t  null) {>                 threadsleep(1)>             }>             systemoutprintln("thread1 started  waiting for it to complete ")>             o1tjoin()>             while (o2t  null) {>                 threadsleep(1)>             }>             systemoutprintln("thread2 started  waiting for it to complete ")>             o2tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads" e)>         }> >         inorder inorder  inorder(observer)>         inorderverify(observer times(1))onnext("one")>         inorderverify(observer times(1))onnext("two")>         inorderverify(observer times(1))onnext("three")>         inorderverify(observer times(1))onnext("four")>         inorderverify(observer times(1))onnext("five")>         inorderverify(observer times(1))onnext("six")>         // we shouldnt have the following 3 yet>         inorderverify(observer never())onnext("seven")>         inorderverify(observer never())onnext("eight")>         inorderverify(observer never())onnext("nine")>         // we should not be completed yet>         verify(observer never())oncompleted()>         verify(observer never())onerror(any(exceptionclass))> >         // now allow the third>         allowthirdcountdown()> >         try {>             while (o3t  null) {>                 threadsleep(1)>             }>             // wait for 3rd to complete>             o3tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads" e)>         }> >         inorderverify(observer times(1))onnext("seven")>         inorderverify(observer times(1))onnext("eight")>         inorderverify(observer times(1))onnext("nine")> >         inorderverify(observer times(1))oncompleted()>         verify(observer never())onerror(any(exceptionclass))>     }> >     @suppresswarnings("unchecked")>     @test>     public void testblockedobservableofobservables() {>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }>         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)>         final countdownlatch callonce  new countdownlatch(1)>         final countdownlatch oktocontinue  new countdownlatch(1)>         testobservable<observable<string>> observableofobservables  new testobservable<observable<string>>(callonce oktocontinue odds even)>         func1<observer<string> subscription> concatf  concat(observableofobservables)>         observable<string> concat  observablecreate(concatf)>         concatsubscribe(observer)>         try {>             //block main thread to allow observables to serve up o1>             callonceawait()>         } catch (exception ex) {>             exprintstacktrace()>             fail(exgetmessage())>         }>         // the concated observable should have served up all of the odds>         verify(observer times(1))onnext("1")>         verify(observer times(1))onnext("3")>         verify(observer times(1))onnext("5")>         verify(observer times(1))onnext("7")> >         try {>             // unblock observables so it can serve up o2 and complete>             oktocontinuecountdown()>             observableofobservablestjoin()>         } catch (exception ex) {>             exprintstacktrace()>             fail(exgetmessage())>         }>         // the concatenated observable should now have served up all the evens>         verify(observer times(1))onnext("2")>         verify(observer times(1))onnext("4")>         verify(observer times(1))onnext("6")>     }> >     private static class testobservable<t> extends observable<t> {> >         private final subscription s  new subscription() {> >             @override>             public void unsubscribe() {>                 subscribed  false>             }> >         }>         private final list<t> values>         private thread t  null>         private int count  0>         private boolean subscribed  true>         private final countdownlatch once>         private final countdownlatch oktocontinue> >         public testobservable(t values) {>             this(null null values)>         }> >         public testobservable(countdownlatch once countdownlatch oktocontinue t values) {>             thisvalues  arraysaslist(values)>             thisonce  once>             thisoktocontinue  oktocontinue>         }> >         @override>         public subscription subscribe(final observer<t> observer) {>             t  new thread(new runnable() {> >                 @override>                 public void run() {>                     try {>                         while (count < valuessize() && subscribed) {>                             observeronnext(valuesget(count))>                             count++>                             //unblock the main thread to call unsubscribe>                             if (null ! once)>                                 oncecountdown()>                             //block until the main thread has called unsubscribe>                             if (null ! once)>                                 oktocontinueawait()>                         }>                         if (subscribed)>                             observeroncompleted()>                     } catch (interruptedexception e) {>                         eprintstacktrace()>                         fail(egetmessage())>                     }>                 }> >             })>             tstart()>             return s>         }> >     }> > }> ```> > > reply to this email directly or view it on github  || #59  #60 thanks for update  let me take a look and i will do some moreresearch/thought on the testconcatsubscribe test caseon fri mar 29 2013 at 2:22 am cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #60 > this pull request looks good> > —> reply to this email directly or view it on github  || [rxjava-pull-requests #72 looks good || my original test case was intended to test the unsubscribe inside one ofchild observable   the countdownlatch was used so that the code will havea chance to unsubscribe in a predicable manner (unsubscribe after "four") in a normal case there should be no blocking between inner and outerobservable  i rewrote the case for better clarity and having the outerobservable is in a separate thread (so the test will pass now)  youbrought up a good point about "when" you can unsubscribe  should it onlyallow unsubscribe to happen during the outer onnext()?  i need to do moreresearch on it  here is the test i plan to add```    @test``` public void testconcatunsubscribeobservableofobservable() {```        final countdownlatch callonce  new countdownlatch(1)        final countdownlatch oktocontinue  new countdownlatch(1)        final testobservable<string> w1  new testobservable<string>(```"one" "two" "three")```        final testobservable<string> w2 ```newtestobservable<string>(callonce oktocontinue"four" "five" "six")```        @suppresswarnings("unchecked")        observer<string> aobserver  mock(observerclass)        @suppresswarnings("unchecked")```   testobservable<observable<string>> observableofobservables newtestobservable<observable<string>>(w1 w2)```        func1<observer<string> subscription> concatf ```concat(observableofobservables)```        observable<string> concat  observablecreate(concatf)        subscription s1  concatsubscribe(aobserver)        try {            //block main thread to allow observable "w1" to complete```and observable "w2" to call onnext exactly once```        callonceawait()        //"four" has been processed by onnext()            s1unsubscribe()            //"five" and "six" will not be processed by onnext()            //unblock the observable to continue            oktocontinuecountdown()            w1tjoin()            w2tjoin()        } catch (exception e) {            eprintstacktrace()            fail(egetmessage())        }        inorder inorder  inorder(aobserver)        inorderverify(aobserver times(1))onnext("one")        inorderverify(aobserver times(1))onnext("two")        inorderverify(aobserver times(1))onnext("three")        inorderverify(aobserver times(1))onnext("four")        inorderverify(aobserver never())onnext("five")        inorderverify(aobserver never())onnext("six")        verify(aobserver never())oncompleted()        verify(aobserver never())onerror(any(exceptionclass))```  }on tue apr 2 2013 at 8:55 pm cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #72 > this pull request looks good> > —> reply to this email directly or view it on github  || the rx net version of concat uses the immediatescheduler to execute theoperation which will execute the operation on the same calling thread  soif the observables are running on the same thread it will besynchronous/blocked   i have pulled in your changes from your fork andadded the additional unit test to test unsubscribe() with observablesrunning in different thread  i have also updated the javadoc about theblocking with observable on the same thread  from my side it looks goodon wed apr 3 2013 at 10:20 am billy yuen billyy@gmailcom wrote:> my original test case was intended to test the unsubscribe inside one of> child observable   the countdownlatch was used so that the code will have> a chance to unsubscribe in a predicable manner (unsubscribe after "four")>  in a normal case there should be no blocking between inner and outer> observable  i rewrote the case for better clarity and having the outer> observable is in a separate thread (so the test will pass now)  you> brought up a good point about "when" you can unsubscribe  should it only> allow unsubscribe to happen during the outer onnext()?  i need to do more> research on it  here is the test i plan to add> > ```>     @test> ```> >  public void testconcatunsubscribeobservableofobservable() {> > ```>         final countdownlatch callonce  new countdownlatch(1)> >         final countdownlatch oktocontinue  new countdownlatch(1)> >         final testobservable<string> w1  new testobservable<string>(> ```> > "one" "two" "three")> > ```>         final testobservable<string> w2  newtestobservable<string>(callonce oktocontinue> ```> > "four" "five" "six")> > ```>         @suppresswarnings("unchecked")> >         observer<string> aobserver  mock(observerclass)> >         @suppresswarnings("unchecked")> ```> >    testobservable<observable<string>> observableofobservables  newtestobservable<observable<string>>(w1 w2)> > ```>         func1<observer<string> subscription> concatf > ```> > concat(observableofobservables)> > ```>         observable<string> concat  observablecreate(concatf)> > > >         subscription s1  concatsubscribe(aobserver)> > > >         try {> >             //block main thread to allow observable "w1" to complete> ```> > and observable "w2" to call onnext exactly once> > ```>         callonceawait()> >         //"four" has been processed by onnext()> >             s1unsubscribe()> >             //"five" and "six" will not be processed by onnext()> >             //unblock the observable to continue> >             oktocontinuecountdown()> >             w1tjoin()> >             w2tjoin()> >         } catch (exception e) {> >             eprintstacktrace()> >             fail(egetmessage())> >         }> > >         inorder inorder  inorder(aobserver)> >         inorderverify(aobserver times(1))onnext("one")> >         inorderverify(aobserver times(1))onnext("two")> >         inorderverify(aobserver times(1))onnext("three")> >         inorderverify(aobserver times(1))onnext("four")> >         inorderverify(aobserver never())onnext("five")> >         inorderverify(aobserver never())onnext("six")> >         verify(aobserver never())oncompleted()> >         verify(aobserver never())onerror(any(exceptionclass))> ```> >   }> > on tue apr 2 2013 at 8:55 pm cloudbees pull request builder plugin <> notifications@githubcom> wrote:> > > rxjava-pull-requests #72 > > > this pull request looks good> > > > —> > reply to this email directly or view it on github >  || > i do find it a little strange that observablefrom(iterable) is a "shotgun> observable" ie the subscribe() blocks until all downstream operations> have completed on all items which means it is impossible to ever> unsubscribe() but given that this is correct behavior i think that it> makes sense that concat(o1 o2) also cannot be unsubscribed-from i added a> cautionary comment to the javadocrx does not (or rarely does) add concurrency (see guideline 612) thus `observablefrom` is wrapping a synchronous iterable therefore the observable will be synchronousa `scheduler` could be used to make the subscription to an iterable happen on another thread or a custom `observable` could be created that handles an iterable asynchronouslyall rx operators must be capable of handling both synchronous and asynchronous sequences and if its synchronous that means unsubscribe will not work (which means its up to the implementor of an observable to understand this and decided if its okay to firehose the results)for the case of concat my concern is that if all the sequences being combined are async then we need to retain the async behavior and not block and prevent unsubscriptionfor example:- async or synchronous observablea with 10 items- async or synchronous observableb with 20 items- async observablec with infinite items (hot observable that never completed)i should be able to do this: `concat(a b c)take(50)` this should get the 10 items from a 20 items from b and first 20 items from c and then unsubscribe and continuedoes this work with the current implementation and correctly unsubscribe from observablec? || good point  the best way to tell is to build an unit test for this case i can expand my new test to include this case and see what happenon wed apr 3 2013 at 2:29 pm ben christensen notifications@githubcomwrote:> i do find it a little strange that observablefrom(iterable) is a "shotgun> observable" ie the subscribe() blocks until all downstream operations> have completed on all items which means it is impossible to ever> unsubscribe() but given that this is correct behavior i think that it> makes sense that concat(o1 o2) also cannot be unsubscribed-from i added a> cautionary comment to the javadoc> > rx does not (or rarely does) add concurrency (see guideline 612) thus> observablefrom is wrapping a synchronous iterable therefore the> observable will be synchronous> > a scheduler could be used to make the subscription to an iterable happen> on another thread or a custom observable could be created that handles> an iterable asynchronously> > all rx operators must be capable of handling both synchronous and> asynchronous sequences and if its synchronous that means unsubscribe will> not work (which means its up to the implementor of an observable to> understand this and decided if its okay to firehose the results)> > for the case of concat my concern is that if all the sequences being> combined are async then we need to retain the async behavior and not block> and prevent unsubscription> > for example:> - async or synchronous observablea with 10 items> - async or synchronous observableb with 20 items> - async observablec with infinite items (hot observable that never>   completed)> > i should be able to do this:> > concat(a b c)take(50)> > this should get the 10 items from a 20 items from b and first 20 items> from c and then unsubscribe and continue> > does this work with the current implementation and correctly unsubscribe> from observablec?> > —> reply to this email directly or view it on github  || 
225,1,0,0,0,0,0,1,0,schedulers (merge of pull #199) manual merge of  by @mairbek plus the following changes:- made some classes non-public so they dont become part of the published api (if we find they have value in the public api we can make them so but once published its hard to remove them so id rather keep them implementation details until then)- consolidated executorscheduler and scheduledexecutorscheduler- made executorscheduler use a system-wide scheduledexecutorscheduler for handling delayed events when only an executor is available- made the iothreadpool use a non-bounded cached thread-pool next step from here is to review all operator implementations and add the scheduler overloads #77  #78 the unit test is poorly written (non-deterministic) ill fix in the morning  || awesome work! - with this it should be easy to implement operators like "sample" etc || yes it should open the gates to many operators we havent been able to pursue || committed a few tweaks and fixesopen questions for me are:- were not using the schedulernow value anywhere should we be? or is that only for the virtual scheduler used for testing?- not quite sure how the overloads should work on `merge` etc  ive implemented them but the behavior might not yet match c# || can someone with an rxnet environment setup implement a test similar to this from java and tell me the output?``` java@test    public void testmixedschedulers() throws interruptedexception {        final string mainthreadname  threadcurrentthread()getname()        observable<string> o  observable<string> create(new func1<observer<string> subscription>() {            @override            public subscription call(observer<string> observer) {                systemoutprintln("origin observable is running on: " + threadcurrentthread()getname())                assertfalse(threadcurrentthread()getname()equals(mainthreadname))                asserttrue("actually: " + threadcurrentthread()getname() threadcurrentthread()getname()startswith("rxiothreadpool"))                observeronnext("one")                observeronnext("two")                observeronnext("three")                observeroncompleted()                return subscriptionsempty()            }        })subscribeon(schedulersthreadpoolforio()) // subscribe to the source on the io thread pool        // now merge on the cpu threadpool        o  observable<string> merge(o observable<string> from("four" "five"))                subscribeon(schedulersthreadpoolforcomputation())                map(new func1<string string>() {                    @override                    public string call(string v) {                        // opportunity to see what thread the merge is running on                        systemoutprintln("merge is running on: " + threadcurrentthread()getname())                        return v                    }                })        final countdownlatch latch  new countdownlatch(1)        final atomicreference<runtimeexception> onerror  new atomicreference<runtimeexception>()        // subscribe on a new thread        osubscribe(new observer<string>() {            @override            public void oncompleted() {                systemoutprintln("> received oncompleted")                latchcountdown()            }            @override            public void onerror(exception e) {                systemoutprintln("> received onerror: " + egetmessage())                onerrorset((runtimeexception) e)                latchcountdown()            }            @override            public void onnext(string v) {                systemoutprintln("> final subscribe is running on: " + threadcurrentthread()getname())                systemoutprintln("> onnext: " + v)            }        } schedulersnewthread())        // wait for the above to finish or blow up if its blocked        latchawait(5 timeunitseconds)    }```im trying to understand how a sequence should work when multiple `subscribeon` operators are applied at different steps of a sequenceof course rxnet doesnt have the io and cpu thread pools  those are just helper methods to executors which would be 2 separate threadpools for different work types so youll need to adjust that || #79 is there any reason to use `schedulerschedule` on an internal operator implementation instead of just leveraging `subscribeon` (other than when we need the delay arguments of course)?for example on a method overload of `merge` is this okay?``` java        return merge(source)subscribeon(scheduler)```or is there some reason to inside the `operationmerge` do this:``` java                return schedulerschedule(new func0<subscription>() {                    @override                    public subscription call() {                        return new mergeobservable<t>(o)call(observer)                    }                })```they seem to accomplish the same thing but would like to know if theres a reason to prefer one over the otheri prefer just reusing `subscribeon` i cant tell from reading c# code what it does as i cant find the extensions that implement the override methods! || im pulling the trigger and merging this into master so people can start playing with it and providing feedbackthe public api changes are fairly limited still so most changes (which i fully expect) will be implementation details || [rxjava-pull-requests #80 looks good || 
225,1,0,1,0,0,0,1,0,schedulers (merge of pull #199) manual merge of  by @mairbek plus the following changes:- made some classes non-public so they dont become part of the published api (if we find they have value in the public api we can make them so but once published its hard to remove them so id rather keep them implementation details until then)- consolidated executorscheduler and scheduledexecutorscheduler- made executorscheduler use a system-wide scheduledexecutorscheduler for handling delayed events when only an executor is available- made the iothreadpool use a non-bounded cached thread-pool next step from here is to review all operator implementations and add the scheduler overloads #77  #78 the unit test is poorly written (non-deterministic) ill fix in the morning  || awesome work! - with this it should be easy to implement operators like "sample" etc || yes it should open the gates to many operators we havent been able to pursue || committed a few tweaks and fixesopen questions for me are:- were not using the schedulernow value anywhere should we be? or is that only for the virtual scheduler used for testing?- not quite sure how the overloads should work on `merge` etc  ive implemented them but the behavior might not yet match c# || can someone with an rxnet environment setup implement a test similar to this from java and tell me the output?``` java@test    public void testmixedschedulers() throws interruptedexception {        final string mainthreadname  threadcurrentthread()getname()        observable<string> o  observable<string> create(new func1<observer<string> subscription>() {            @override            public subscription call(observer<string> observer) {                systemoutprintln("origin observable is running on: " + threadcurrentthread()getname())                assertfalse(threadcurrentthread()getname()equals(mainthreadname))                asserttrue("actually: " + threadcurrentthread()getname() threadcurrentthread()getname()startswith("rxiothreadpool"))                observeronnext("one")                observeronnext("two")                observeronnext("three")                observeroncompleted()                return subscriptionsempty()            }        })subscribeon(schedulersthreadpoolforio()) // subscribe to the source on the io thread pool        // now merge on the cpu threadpool        o  observable<string> merge(o observable<string> from("four" "five"))                subscribeon(schedulersthreadpoolforcomputation())                map(new func1<string string>() {                    @override                    public string call(string v) {                        // opportunity to see what thread the merge is running on                        systemoutprintln("merge is running on: " + threadcurrentthread()getname())                        return v                    }                })        final countdownlatch latch  new countdownlatch(1)        final atomicreference<runtimeexception> onerror  new atomicreference<runtimeexception>()        // subscribe on a new thread        osubscribe(new observer<string>() {            @override            public void oncompleted() {                systemoutprintln("> received oncompleted")                latchcountdown()            }            @override            public void onerror(exception e) {                systemoutprintln("> received onerror: " + egetmessage())                onerrorset((runtimeexception) e)                latchcountdown()            }            @override            public void onnext(string v) {                systemoutprintln("> final subscribe is running on: " + threadcurrentthread()getname())                systemoutprintln("> onnext: " + v)            }        } schedulersnewthread())        // wait for the above to finish or blow up if its blocked        latchawait(5 timeunitseconds)    }```im trying to understand how a sequence should work when multiple `subscribeon` operators are applied at different steps of a sequenceof course rxnet doesnt have the io and cpu thread pools  those are just helper methods to executors which would be 2 separate threadpools for different work types so youll need to adjust that || #79 is there any reason to use `schedulerschedule` on an internal operator implementation instead of just leveraging `subscribeon` (other than when we need the delay arguments of course)?for example on a method overload of `merge` is this okay?``` java        return merge(source)subscribeon(scheduler)```or is there some reason to inside the `operationmerge` do this:``` java                return schedulerschedule(new func0<subscription>() {                    @override                    public subscription call() {                        return new mergeobservable<t>(o)call(observer)                    }                })```they seem to accomplish the same thing but would like to know if theres a reason to prefer one over the otheri prefer just reusing `subscribeon` i cant tell from reading c# code what it does as i cant find the extensions that implement the override methods! || im pulling the trigger and merging this into master so people can start playing with it and providing feedbackthe public api changes are fairly limited still so most changes (which i fully expect) will be implementation details || [rxjava-pull-requests #80 looks good || 
225,1,0,1,1,1,1,1,1,schedulers (merge of pull #199) manual merge of  by @mairbek plus the following changes:- made some classes non-public so they dont become part of the published api (if we find they have value in the public api we can make them so but once published its hard to remove them so id rather keep them implementation details until then)- consolidated executorscheduler and scheduledexecutorscheduler- made executorscheduler use a system-wide scheduledexecutorscheduler for handling delayed events when only an executor is available- made the iothreadpool use a non-bounded cached thread-pool next step from here is to review all operator implementations and add the scheduler overloads #77  #78 the unit test is poorly written (non-deterministic) ill fix in the morning  || awesome work! - with this it should be easy to implement operators like "sample" etc || yes it should open the gates to many operators we havent been able to pursue || committed a few tweaks and fixesopen questions for me are:- were not using the schedulernow value anywhere should we be? or is that only for the virtual scheduler used for testing?- not quite sure how the overloads should work on `merge` etc  ive implemented them but the behavior might not yet match c# || can someone with an rxnet environment setup implement a test similar to this from java and tell me the output?``` java@test    public void testmixedschedulers() throws interruptedexception {        final string mainthreadname  threadcurrentthread()getname()        observable<string> o  observable<string> create(new func1<observer<string> subscription>() {            @override            public subscription call(observer<string> observer) {                systemoutprintln("origin observable is running on: " + threadcurrentthread()getname())                assertfalse(threadcurrentthread()getname()equals(mainthreadname))                asserttrue("actually: " + threadcurrentthread()getname() threadcurrentthread()getname()startswith("rxiothreadpool"))                observeronnext("one")                observeronnext("two")                observeronnext("three")                observeroncompleted()                return subscriptionsempty()            }        })subscribeon(schedulersthreadpoolforio()) // subscribe to the source on the io thread pool        // now merge on the cpu threadpool        o  observable<string> merge(o observable<string> from("four" "five"))                subscribeon(schedulersthreadpoolforcomputation())                map(new func1<string string>() {                    @override                    public string call(string v) {                        // opportunity to see what thread the merge is running on                        systemoutprintln("merge is running on: " + threadcurrentthread()getname())                        return v                    }                })        final countdownlatch latch  new countdownlatch(1)        final atomicreference<runtimeexception> onerror  new atomicreference<runtimeexception>()        // subscribe on a new thread        osubscribe(new observer<string>() {            @override            public void oncompleted() {                systemoutprintln("> received oncompleted")                latchcountdown()            }            @override            public void onerror(exception e) {                systemoutprintln("> received onerror: " + egetmessage())                onerrorset((runtimeexception) e)                latchcountdown()            }            @override            public void onnext(string v) {                systemoutprintln("> final subscribe is running on: " + threadcurrentthread()getname())                systemoutprintln("> onnext: " + v)            }        } schedulersnewthread())        // wait for the above to finish or blow up if its blocked        latchawait(5 timeunitseconds)    }```im trying to understand how a sequence should work when multiple `subscribeon` operators are applied at different steps of a sequenceof course rxnet doesnt have the io and cpu thread pools  those are just helper methods to executors which would be 2 separate threadpools for different work types so youll need to adjust that || #79 is there any reason to use `schedulerschedule` on an internal operator implementation instead of just leveraging `subscribeon` (other than when we need the delay arguments of course)?for example on a method overload of `merge` is this okay?``` java        return merge(source)subscribeon(scheduler)```or is there some reason to inside the `operationmerge` do this:``` java                return schedulerschedule(new func0<subscription>() {                    @override                    public subscription call() {                        return new mergeobservable<t>(o)call(observer)                    }                })```they seem to accomplish the same thing but would like to know if theres a reason to prefer one over the otheri prefer just reusing `subscribeon` i cant tell from reading c# code what it does as i cant find the extensions that implement the override methods! || im pulling the trigger and merging this into master so people can start playing with it and providing feedbackthe public api changes are fairly limited still so most changes (which i fully expect) will be implementation details || [rxjava-pull-requests #80 looks good || 
228,1,0,0,0,0,0,1,0,interval i have attempted to implement the "interval" operator (#55) here as far as i can see it seems to work this is based on the quite fresh work on schedulersit doesnt work with the `currentthread` or `newthread` schedulers i guess due to the simple `sleepingaction` it does work with a `scheduledexecutorservice` thoughfor testing this conveniently i also wrote a test scheduler with adjustable timelooking forward to any review comments #83 #84  lets consider adding new method to the `scheduler```` javascheduleperiodically(action0 action long initialdelay long period timeunit unit) ```it would allow to leverage `scheduledexecutorservice#scheduleatrate` for the `executorscheduler` for other schedulers we could use recursive action scheduling from pull request #229  || i agree `scheduleperiodically` would be helpful here || @jmhofer do you plan to work on this feature? im thinking about implementing buffer operator #16 and this one will be very helpful for me || ill have a look at it || maybe we should also combine all the longs and units into a timespan class? - it doesnt feel right to always have them as separate parameters || anyone know why net wouldnt have a `scheduleperiodically` concept? if we were to add that it would only really work with `scheduledexecutorservice` and thus most `scheduler` implementations would have to rely upon the generic `scheduledexecutorservice` that ive added in  called `genericscheduledexecutorservice`this suggests to me that it isnt the right solution to add another interface method as it seems very tied to a particular implementation cant this be achieved with recursive schedulers which now work after the changes you did in  || im curious about this:> it doesnt work with the currentthread or newthread schedulers i guess due to the simple sleepingaction it does work with a scheduledexecutorservice thoughit seems that this operator needs to be async and must default to using something like `schedulersthreadpoolforcomputation()`documentation at msdn ( suggests that this defaults to using a thread-pool scheduler:> the following example code uses the interval operator to generate a sequence of long integers staring at zero each integer in the sequence is generated after the two second period has expired each integer is written to the console window along with the current time to show the period parameter in effect the generation of the integer sequence is scheduled to run on a thread from the net thread pool so the main thread is not blocked and can process the enter key being pressed to stop the intervalperhaps `newthreadscheduler` will work as of  because it now uses `genericscheduledexecutorservice` when a delay is passed in instead of `sleepingaction`what happens in net if someone tries to use `immediatescheduler` or `currentthreadscheduler`? anyone have access to net to try that? || > maybe we should also combine all the longs and units into a timespan class? - it doesnt feel right to always have them as separate parametersif were going to consider doing this then we should do it as part of  before i release another version since this would change the `schedulers` interfacejava itself always keeps the 2 separate though so perhaps the idiomatic thing to do in java is to keep them separate? i dont have a strong opinion on this one but the decision made now will last a very long time || actually net does have `scheduleperiodic` see here:  its useful to avoid recursive scheduling where the schedulers support this directly as well as to do the slightly messy recursive scheduling ourselves for other types of schedulers so that the user doesnt have to || ah interesting thanks for educating me on that || this doesnt look like its been integrated into observable but im going to merge as it looks useful to get this in  the testscheduler especially while interval continues getting work done || great thanks (this still needs a bit of work if/when we do periodic scheduling) || are you okay with me releasing current code on the master branch and then the rest of `interval` coming later?is there anything else about master branch as it stands that should be changed before i release? id like to do so today || thats alright with me || @benjchristensen now the `interval` operators in rxjava and rxnet have different behaviors when the scheduler is `currentthread`in rxnet the following codes``` c#            var o  observableinterval(timespanfrommilliseconds(100) schedulercurrentthread)            otake(5)subscribe(                x > consolewriteline(x)            )            otake(4)subscribe(                x > consolewriteline(x)            )            consolereadline()```output```012340123```in rxjava the following codes``` java            observable<long> o   observableinterval(100 timeunitmilliseconds                    schedulerscurrentthread())            otake(5)subscribe(new action1<long>() {                @override                public void call(long t1) {                    systemoutprintln(t1)                }            })            otake(4)subscribe(new action1<long>() {                @override                public void call(long t1) {                    systemoutprintln(t1)                }            })```output```01234```and the current thread is blocked at the first `subscribe`is it ok or the `interval` operator should not be used with `currentthread`? ||
228,1,0,1,0,0,0,1,0,interval i have attempted to implement the "interval" operator (#55) here as far as i can see it seems to work this is based on the quite fresh work on schedulersit doesnt work with the `currentthread` or `newthread` schedulers i guess due to the simple `sleepingaction` it does work with a `scheduledexecutorservice` thoughfor testing this conveniently i also wrote a test scheduler with adjustable timelooking forward to any review comments #83 #84  lets consider adding new method to the `scheduler```` javascheduleperiodically(action0 action long initialdelay long period timeunit unit) ```it would allow to leverage `scheduledexecutorservice#scheduleatrate` for the `executorscheduler` for other schedulers we could use recursive action scheduling from pull request #229  || i agree `scheduleperiodically` would be helpful here || @jmhofer do you plan to work on this feature? im thinking about implementing buffer operator #16 and this one will be very helpful for me || ill have a look at it || maybe we should also combine all the longs and units into a timespan class? - it doesnt feel right to always have them as separate parameters || anyone know why net wouldnt have a `scheduleperiodically` concept? if we were to add that it would only really work with `scheduledexecutorservice` and thus most `scheduler` implementations would have to rely upon the generic `scheduledexecutorservice` that ive added in  called `genericscheduledexecutorservice`this suggests to me that it isnt the right solution to add another interface method as it seems very tied to a particular implementation cant this be achieved with recursive schedulers which now work after the changes you did in  || im curious about this:> it doesnt work with the currentthread or newthread schedulers i guess due to the simple sleepingaction it does work with a scheduledexecutorservice thoughit seems that this operator needs to be async and must default to using something like `schedulersthreadpoolforcomputation()`documentation at msdn ( suggests that this defaults to using a thread-pool scheduler:> the following example code uses the interval operator to generate a sequence of long integers staring at zero each integer in the sequence is generated after the two second period has expired each integer is written to the console window along with the current time to show the period parameter in effect the generation of the integer sequence is scheduled to run on a thread from the net thread pool so the main thread is not blocked and can process the enter key being pressed to stop the intervalperhaps `newthreadscheduler` will work as of  because it now uses `genericscheduledexecutorservice` when a delay is passed in instead of `sleepingaction`what happens in net if someone tries to use `immediatescheduler` or `currentthreadscheduler`? anyone have access to net to try that? || > maybe we should also combine all the longs and units into a timespan class? - it doesnt feel right to always have them as separate parametersif were going to consider doing this then we should do it as part of  before i release another version since this would change the `schedulers` interfacejava itself always keeps the 2 separate though so perhaps the idiomatic thing to do in java is to keep them separate? i dont have a strong opinion on this one but the decision made now will last a very long time || actually net does have `scheduleperiodic` see here:  its useful to avoid recursive scheduling where the schedulers support this directly as well as to do the slightly messy recursive scheduling ourselves for other types of schedulers so that the user doesnt have to || ah interesting thanks for educating me on that || this doesnt look like its been integrated into observable but im going to merge as it looks useful to get this in  the testscheduler especially while interval continues getting work done || great thanks (this still needs a bit of work if/when we do periodic scheduling) || are you okay with me releasing current code on the master branch and then the rest of `interval` coming later?is there anything else about master branch as it stands that should be changed before i release? id like to do so today || thats alright with me || @benjchristensen now the `interval` operators in rxjava and rxnet have different behaviors when the scheduler is `currentthread`in rxnet the following codes``` c#            var o  observableinterval(timespanfrommilliseconds(100) schedulercurrentthread)            otake(5)subscribe(                x > consolewriteline(x)            )            otake(4)subscribe(                x > consolewriteline(x)            )            consolereadline()```output```012340123```in rxjava the following codes``` java            observable<long> o   observableinterval(100 timeunitmilliseconds                    schedulerscurrentthread())            otake(5)subscribe(new action1<long>() {                @override                public void call(long t1) {                    systemoutprintln(t1)                }            })            otake(4)subscribe(new action1<long>() {                @override                public void call(long t1) {                    systemoutprintln(t1)                }            })```output```01234```and the current thread is blocked at the first `subscribe`is it ok or the `interval` operator should not be used with `currentthread`? ||
228,1,0,0,0,0,0,1,0,interval i have attempted to implement the "interval" operator (#55) here as far as i can see it seems to work this is based on the quite fresh work on schedulersit doesnt work with the `currentthread` or `newthread` schedulers i guess due to the simple `sleepingaction` it does work with a `scheduledexecutorservice` thoughfor testing this conveniently i also wrote a test scheduler with adjustable timelooking forward to any review comments #83 #84  lets consider adding new method to the `scheduler```` javascheduleperiodically(action0 action long initialdelay long period timeunit unit) ```it would allow to leverage `scheduledexecutorservice#scheduleatrate` for the `executorscheduler` for other schedulers we could use recursive action scheduling from pull request #229  || i agree `scheduleperiodically` would be helpful here || @jmhofer do you plan to work on this feature? im thinking about implementing buffer operator #16 and this one will be very helpful for me || ill have a look at it || maybe we should also combine all the longs and units into a timespan class? - it doesnt feel right to always have them as separate parameters || anyone know why net wouldnt have a `scheduleperiodically` concept? if we were to add that it would only really work with `scheduledexecutorservice` and thus most `scheduler` implementations would have to rely upon the generic `scheduledexecutorservice` that ive added in  called `genericscheduledexecutorservice`this suggests to me that it isnt the right solution to add another interface method as it seems very tied to a particular implementation cant this be achieved with recursive schedulers which now work after the changes you did in  || im curious about this:> it doesnt work with the currentthread or newthread schedulers i guess due to the simple sleepingaction it does work with a scheduledexecutorservice thoughit seems that this operator needs to be async and must default to using something like `schedulersthreadpoolforcomputation()`documentation at msdn ( suggests that this defaults to using a thread-pool scheduler:> the following example code uses the interval operator to generate a sequence of long integers staring at zero each integer in the sequence is generated after the two second period has expired each integer is written to the console window along with the current time to show the period parameter in effect the generation of the integer sequence is scheduled to run on a thread from the net thread pool so the main thread is not blocked and can process the enter key being pressed to stop the intervalperhaps `newthreadscheduler` will work as of  because it now uses `genericscheduledexecutorservice` when a delay is passed in instead of `sleepingaction`what happens in net if someone tries to use `immediatescheduler` or `currentthreadscheduler`? anyone have access to net to try that? || > maybe we should also combine all the longs and units into a timespan class? - it doesnt feel right to always have them as separate parametersif were going to consider doing this then we should do it as part of  before i release another version since this would change the `schedulers` interfacejava itself always keeps the 2 separate though so perhaps the idiomatic thing to do in java is to keep them separate? i dont have a strong opinion on this one but the decision made now will last a very long time || actually net does have `scheduleperiodic` see here:  its useful to avoid recursive scheduling where the schedulers support this directly as well as to do the slightly messy recursive scheduling ourselves for other types of schedulers so that the user doesnt have to || ah interesting thanks for educating me on that || this doesnt look like its been integrated into observable but im going to merge as it looks useful to get this in  the testscheduler especially while interval continues getting work done || great thanks (this still needs a bit of work if/when we do periodic scheduling) || are you okay with me releasing current code on the master branch and then the rest of `interval` coming later?is there anything else about master branch as it stands that should be changed before i release? id like to do so today || thats alright with me || @benjchristensen now the `interval` operators in rxjava and rxnet have different behaviors when the scheduler is `currentthread`in rxnet the following codes``` c#            var o  observableinterval(timespanfrommilliseconds(100) schedulercurrentthread)            otake(5)subscribe(                x > consolewriteline(x)            )            otake(4)subscribe(                x > consolewriteline(x)            )            consolereadline()```output```012340123```in rxjava the following codes``` java            observable<long> o   observableinterval(100 timeunitmilliseconds                    schedulerscurrentthread())            otake(5)subscribe(new action1<long>() {                @override                public void call(long t1) {                    systemoutprintln(t1)                }            })            otake(4)subscribe(new action1<long>() {                @override                public void call(long t1) {                    systemoutprintln(t1)                }            })```output```01234```and the current thread is blocked at the first `subscribe`is it ok or the `interval` operator should not be used with `currentthread`? ||
229,1,0,0,0,0,0,1,0,trying to extend the scheduler interface according to the comments at ive tried to extend the `scheduler` interface according to the discussion at issue #19 if i understand this correctly most of it can be done via the `abstractscheduler`i hope this helps please have a look #85  awesome looks like it doesnt break a `scheduler` interface i thought about two examples``` java        final scheduler scheduler  schedulerscurrentthread()        observable<integer> obs  observablecreate(new func1<observer<integer> subscription>() {            @override            public subscription call(final observer<integer> observer) {                return schedulerschedule(0 new func2<scheduler integer subscription>() {                    @override                    public subscription call(scheduler scheduler integer i) {                        if (i > 42) {                            observeroncompleted()                            return subscriptionsempty()                        }                        observeronnext(i)                        return schedulerschedule(i + 1 this)                    }                })            }        })        obssubscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln("completed")            }            @override            public void onerror(exception e) {                systemoutprintln("error")            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })```and``` java        final scheduler scheduler  schedulersthreadpoolforcomputation()        observable<integer> obs  observablecreate(new func1<observer<integer> subscription>() {            @override            public subscription call(final observer<integer> observer) {                return schedulerschedule(new booleansubscription() new func2<scheduler booleansubscription subscription>() {                    @override                    public subscription call(scheduler scheduler booleansubscription cancel) {                        if (cancelisunsubscribed()) {                            observeroncompleted()                            return subscriptionsempty()                        }                        observeronnext(42)                        try {                            threadsleep(1000)                        } catch (interruptedexception e) {                            eprintstacktrace()                        }                        schedulerschedule(cancel this)                        return cancel                    }                })            }        })        subscription subscribe  obssubscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln("completed")            }            @override            public void onerror(exception e) {                systemoutprintln("error")            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })        threadsleep(10000)        subscribeunsubscribe()        systemoutprintln("unsubscribe")        threadsleep(10000)```and they worked well for me || im wondering if the `scheduler` interface really needs all of these overloads?rx has 3 primary methods (the rest are extension methods that look like they do transformations) the 2 key ones are:``` java<t> subscription schedule(t state func2<scheduler t subscription> action)<t> subscription schedule(t state func2<scheduler t subscription> action long duetime timeunit unit)```we dont have one with an explicit time to run only relative at this time || it appears the overloads all make sense  but again net is able to use extension methods to make the design much more elegant where only the main 3 are part of the interface and the rest come along for the rideit means we end up with a scheduler/abstractscheduler interface/abstract pairing to make this workshould we just make scheduler an abstract? im very tempted to do so because of the following problems:- adding methods to scheduler will be breaking changes requiring major version increments- people implementing schedulers will basically always have to also extend abstractscheduler or copy/paste all of those method overloadsor should be remove all but the main 3 methods from scheduler and put all the overloads as utility functions on the schedulers class instead?the precedent for using abstract (or concrete) classes instead of interfaces (which net then augments with extension methods) is already done - observable is a concrete class instead of interface for this very reasonall plugins  as abstracts instead of interfaces for this reason as wellthoughts? || while reviewing and playing with this i considered some changes id like to propose i have submitted another pull request ( that builds on top of your work @jmhofer and includes the unit tests from @mairbek i would appreciate your thoughts on it and whether they are beneficial changes or just pedantic || merged manually via  || 
229,1,0,0,0,1,1,1,1,trying to extend the scheduler interface according to the comments at ive tried to extend the `scheduler` interface according to the discussion at issue #19 if i understand this correctly most of it can be done via the `abstractscheduler`i hope this helps please have a look #85  awesome looks like it doesnt break a `scheduler` interface i thought about two examples``` java        final scheduler scheduler  schedulerscurrentthread()        observable<integer> obs  observablecreate(new func1<observer<integer> subscription>() {            @override            public subscription call(final observer<integer> observer) {                return schedulerschedule(0 new func2<scheduler integer subscription>() {                    @override                    public subscription call(scheduler scheduler integer i) {                        if (i > 42) {                            observeroncompleted()                            return subscriptionsempty()                        }                        observeronnext(i)                        return schedulerschedule(i + 1 this)                    }                })            }        })        obssubscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln("completed")            }            @override            public void onerror(exception e) {                systemoutprintln("error")            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })```and``` java        final scheduler scheduler  schedulersthreadpoolforcomputation()        observable<integer> obs  observablecreate(new func1<observer<integer> subscription>() {            @override            public subscription call(final observer<integer> observer) {                return schedulerschedule(new booleansubscription() new func2<scheduler booleansubscription subscription>() {                    @override                    public subscription call(scheduler scheduler booleansubscription cancel) {                        if (cancelisunsubscribed()) {                            observeroncompleted()                            return subscriptionsempty()                        }                        observeronnext(42)                        try {                            threadsleep(1000)                        } catch (interruptedexception e) {                            eprintstacktrace()                        }                        schedulerschedule(cancel this)                        return cancel                    }                })            }        })        subscription subscribe  obssubscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln("completed")            }            @override            public void onerror(exception e) {                systemoutprintln("error")            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })        threadsleep(10000)        subscribeunsubscribe()        systemoutprintln("unsubscribe")        threadsleep(10000)```and they worked well for me || im wondering if the `scheduler` interface really needs all of these overloads?rx has 3 primary methods (the rest are extension methods that look like they do transformations) the 2 key ones are:``` java<t> subscription schedule(t state func2<scheduler t subscription> action)<t> subscription schedule(t state func2<scheduler t subscription> action long duetime timeunit unit)```we dont have one with an explicit time to run only relative at this time || it appears the overloads all make sense  but again net is able to use extension methods to make the design much more elegant where only the main 3 are part of the interface and the rest come along for the rideit means we end up with a scheduler/abstractscheduler interface/abstract pairing to make this workshould we just make scheduler an abstract? im very tempted to do so because of the following problems:- adding methods to scheduler will be breaking changes requiring major version increments- people implementing schedulers will basically always have to also extend abstractscheduler or copy/paste all of those method overloadsor should be remove all but the main 3 methods from scheduler and put all the overloads as utility functions on the schedulers class instead?the precedent for using abstract (or concrete) classes instead of interfaces (which net then augments with extension methods) is already done - observable is a concrete class instead of interface for this very reasonall plugins  as abstracts instead of interfaces for this reason as wellthoughts? || while reviewing and playing with this i considered some changes id like to propose i have submitted another pull request ( that builds on top of your work @jmhofer and includes the unit tests from @mairbek i would appreciate your thoughts on it and whether they are beneficial changes or just pedantic || merged manually via  || 
229,1,0,0,0,1,1,1,1,trying to extend the scheduler interface according to the comments at ive tried to extend the `scheduler` interface according to the discussion at issue #19 if i understand this correctly most of it can be done via the `abstractscheduler`i hope this helps please have a look #85  awesome looks like it doesnt break a `scheduler` interface i thought about two examples``` java        final scheduler scheduler  schedulerscurrentthread()        observable<integer> obs  observablecreate(new func1<observer<integer> subscription>() {            @override            public subscription call(final observer<integer> observer) {                return schedulerschedule(0 new func2<scheduler integer subscription>() {                    @override                    public subscription call(scheduler scheduler integer i) {                        if (i > 42) {                            observeroncompleted()                            return subscriptionsempty()                        }                        observeronnext(i)                        return schedulerschedule(i + 1 this)                    }                })            }        })        obssubscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln("completed")            }            @override            public void onerror(exception e) {                systemoutprintln("error")            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })```and``` java        final scheduler scheduler  schedulersthreadpoolforcomputation()        observable<integer> obs  observablecreate(new func1<observer<integer> subscription>() {            @override            public subscription call(final observer<integer> observer) {                return schedulerschedule(new booleansubscription() new func2<scheduler booleansubscription subscription>() {                    @override                    public subscription call(scheduler scheduler booleansubscription cancel) {                        if (cancelisunsubscribed()) {                            observeroncompleted()                            return subscriptionsempty()                        }                        observeronnext(42)                        try {                            threadsleep(1000)                        } catch (interruptedexception e) {                            eprintstacktrace()                        }                        schedulerschedule(cancel this)                        return cancel                    }                })            }        })        subscription subscribe  obssubscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln("completed")            }            @override            public void onerror(exception e) {                systemoutprintln("error")            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })        threadsleep(10000)        subscribeunsubscribe()        systemoutprintln("unsubscribe")        threadsleep(10000)```and they worked well for me || im wondering if the `scheduler` interface really needs all of these overloads?rx has 3 primary methods (the rest are extension methods that look like they do transformations) the 2 key ones are:``` java<t> subscription schedule(t state func2<scheduler t subscription> action)<t> subscription schedule(t state func2<scheduler t subscription> action long duetime timeunit unit)```we dont have one with an explicit time to run only relative at this time || it appears the overloads all make sense  but again net is able to use extension methods to make the design much more elegant where only the main 3 are part of the interface and the rest come along for the rideit means we end up with a scheduler/abstractscheduler interface/abstract pairing to make this workshould we just make scheduler an abstract? im very tempted to do so because of the following problems:- adding methods to scheduler will be breaking changes requiring major version increments- people implementing schedulers will basically always have to also extend abstractscheduler or copy/paste all of those method overloadsor should be remove all but the main 3 methods from scheduler and put all the overloads as utility functions on the schedulers class instead?the precedent for using abstract (or concrete) classes instead of interfaces (which net then augments with extension methods) is already done - observable is a concrete class instead of interface for this very reasonall plugins  as abstracts instead of interfaces for this reason as wellthoughts? || while reviewing and playing with this i considered some changes id like to propose i have submitted another pull request ( that builds on top of your work @jmhofer and includes the unit tests from @mairbek i would appreciate your thoughts on it and whether they are beneficial changes or just pedantic || merged manually via  || 
248,1,0,0,0,0,0,1,0,implemented sample operation now that `operationinterval` is in `operationsample` (see  #74) was kind of straightforward i also added a unit test against sampling and allowed for specifying a scheduler used by the sample operation #108  we want methods on `observable` dont we? || sure i just completely forgot about that ill add them || #113
248,1,0,0,1,1,1,1,1,implemented sample operation now that `operationinterval` is in `operationsample` (see  #74) was kind of straightforward i also added a unit test against sampling and allowed for specifying a scheduler used by the sample operation #108  we want methods on `observable` dont we? || sure i just completely forgot about that ill add them || #113
248,1,0,0,1,1,1,1,1,implemented sample operation now that `operationinterval` is in `operationsample` (see  #74) was kind of straightforward i also added a unit test against sampling and allowed for specifying a scheduler used by the sample operation #108  we want methods on `observable` dont we? || sure i just completely forgot about that ill add them || #113
249,1,0,0,0,0,0,1,0,timestamp operation straightforward implementation of issue #93 based on `operationmap` (without the scheduler version as `map` doesnt take a scheduler yet either) #109 the failing test has nothing to do with my changes - i guess its a sporadic test problem as theres not much difference between 10 and 30 milliseconds || this should also be added to `observable` shouldnt it? || #112 my eclipse configuration also automatically added a lot of `@override` annotations i hope you dont mind otherwise i can remove them again of course || the @override annotations are fine - they are standard java they may be missing in some places because this project started with java 5 compliance and it had the annotations in less places than java 6  ||
249,1,0,1,1,0,1,1,1,timestamp operation straightforward implementation of issue #93 based on `operationmap` (without the scheduler version as `map` doesnt take a scheduler yet either) #109 the failing test has nothing to do with my changes - i guess its a sporadic test problem as theres not much difference between 10 and 30 milliseconds || this should also be added to `observable` shouldnt it? || #112 my eclipse configuration also automatically added a lot of `@override` annotations i hope you dont mind otherwise i can remove them again of course || the @override annotations are fine - they are standard java they may be missing in some places because this project started with java 5 compliance and it had the annotations in less places than java 6  ||
249,1,0,0,0,0,0,1,0,timestamp operation straightforward implementation of issue #93 based on `operationmap` (without the scheduler version as `map` doesnt take a scheduler yet either) #109 the failing test has nothing to do with my changes - i guess its a sporadic test problem as theres not much difference between 10 and 30 milliseconds || this should also be added to `observable` shouldnt it? || #112 my eclipse configuration also automatically added a lot of `@override` annotations i hope you dont mind otherwise i can remove them again of course || the @override annotations are fine - they are standard java they may be missing in some places because this project started with java 5 compliance and it had the annotations in less places than java 6  ||
